<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手机端页面自适应【转】]]></title>
    <url>%2F2018%2F07%2F14%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%87%AA%E9%80%82%E5%BA%94%E3%80%90%E8%BD%AC%E3%80%91%2F</url>
    <content type="text"><![CDATA[相信很多刚开始写移动端页面的同学都要面对页面自适应的问题，当然解决方案很多，比如：百分比布局，弹性布局flex（什么是flex），也都能获得不错的效果，这里主要介绍的是本人在实践中用的最顺手最简单的布局方案——rem布局 rem布局非常简单，首页你只需在页面引入这段原生js代码就可以了 1234567891011121314151617(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=640)&#123; docEl.style.fontSize = &apos;100px&apos;; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 640) + &apos;px&apos;; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false); &#125;)(document, window); 如何使用？ 这是rem布局的核心代码，这段代码的大意是：如果页面的宽度超过了640px，那么页面中html的font-size恒为100px，否则，页面中html的font-size的大小为： 100 * (当前页面宽度 / 640)于是，问题来了，为什么要这样？ 1. 为什么是640px？对于手机屏幕来说，640px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而它的CSS逻辑像素数为320 x 568px。如果要切移动端页面，你可以先把效果图宽度等比例缩放到640px，很好用。 2. 为什么要设置html的font-size？rem就是根元素（即：html）的字体大小。html中的所有标签样式凡是涉及到尺寸的（如： height,width,padding,margin,font-size。甚至，left,top等）你都可以放心大胆的用rem作单位。如果你把html的font-size设为20px，前面说过，rem就是html的字体大小，那么1rem = 20px。此时，此时宽60px，高40px的元素样式就这样设置如下 12width: 3rem;height: 2rem; 那要是宽55px，高37px呢？然后经过换算，设置如下 12width: 2.75rem;height: 1.85rem; 是不是发现这换算起来有点麻烦啊，，，（当然，你要是心算帝请无视）如果我们一开始把html的font-size设为100px呢？此时1rem = 100px，那么上面的宽55px，高37px的元素样式就可以这么设置 12width: 0.55rem;height: 0.37rem; 是不是换算起来简单多了？！（当然可能有同学问，为什么不一开始把html的font-size设为1px呢，这样换算起来也简单，答：浏览器一般都有最小字体限制，比如谷歌浏览器，最小中文字体就是12px，所以实际上没有办法让1rem=1px。）根据上面的js代码，如果页面宽度低于640px,那么页面中html的font-size也会按照（当前页面宽度/640）的比例变化。这样，页面中凡是应用了rem的作尺寸单位的元素都会随着页面变化而等比例缩放了！ 3. 都哪些情况可以用rem布局？大部分情况下都可以用rem布局这个方法，当然具体还要看情况而定。拿我们公司项目举例，只有底部的导航不用rem，而是用的flex布局。因为导航点击最多，所以给它一个固定的大小（其实就是高度固定，宽度自适应的方案）。大家可以看看淘宝的这个手机页面 淘宝手机站，基本就是这种感觉，底部导航和顶部搜索框用的高固定，宽自适应的方案，其余的部分基本都是随着浏览器宽度变化在等比例缩放。 最终页面代码首页代码大致如下12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; &lt;script&gt; (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=640)&#123; docEl.style.fontSize = &apos;100px&apos;; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 640) + &apos;px&apos;; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false); &#125;)(document, window);&lt;/script&gt; /*你引进的资源*/&lt;title&gt;标题&lt;/title&gt; &lt;/head&gt;&lt;body&gt; /*你的代码*/&lt;/body&gt;&lt;/html&gt; rem布局（进阶版） 另外： 此方案仅适用于移动端web 文章底部常见问题说明第四条，笔者已给出一个相当便捷的解决方案，欢迎留言交流。 该方案使用相当简单，把下面这段已压缩过的 原生JS（仅1kb，源码已在文章） 放到 HTML 的 head 标签中即可（注:不要手动设置viewport，该方案自动帮你设置） 1&lt;script&gt;!function(e)&#123;function t(a)&#123;if(i[a])return i[a].exports;var n=i[a]=&#123;exports:&#123;&#125;,id:a,loaded:!1&#125;;return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var i=&#123;&#125;;return t.m=e,t.c=i,t.p=&quot;&quot;,t(0)&#125;([function(e,t)&#123;&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,&#123;value:!0&#125;);var i=window;t[&quot;default&quot;]=i.flex=function(normal,e,t)&#123;var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i),l=o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i),c=l&amp;&amp;parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;),10)&gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;&amp;d[1]&gt;534||c||(s=1);var u=normal?1:1/s,m=r.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);m||(m=r.createElement(&quot;meta&quot;),m.setAttribute(&quot;name&quot;,&quot;viewport&quot;),r.head.appendChild(m)),m.setAttribute(&quot;content&quot;,&quot;width=device-width,user-scalable=no,initial-scale=&quot;+u+&quot;,maximum-scale=&quot;+u+&quot;,minimum-scale=&quot;+u),r.documentElement.style.fontSize=normal?&quot;50px&quot;: a/2*s*n+&quot;px&quot;&#125;,e.exports=t[&quot;default&quot;]&#125;]); flex(false,100, 1);&lt;/script&gt; 代码原理这是阿里团队的高清方案布局代码，所谓高清方案就是根据设备屏幕的DPR（设备像素比，又称DPPX，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的font-size, 同时根据设备DPR调整页面的缩放值，进而达到高清效果。 有何优势 引用简单，布局简便 根据设备屏幕的DPR,自动设置最合适的高清缩放。 保证了不同设备下视觉体验的一致性。（老方案是，屏幕越大元素越大；此方案是，屏幕越大，看的越多） 有效解决移动端真实1px问题（这里的1px 是设备屏幕上的物理像素） 如何使用重要的事情说三遍！绝不是每个地方都要用rem，rem只适用于固定尺寸！绝不是每个地方都要用rem，rem只适用于固定尺寸！绝不是每个地方都要用rem，rem只适用于固定尺寸！在相当数量的布局情境中（比如底部导航元素平分屏幕宽，大尺寸元素），你必须使用百分比或者flex才能完美布局！此方案也是默认 1rem = 100px，所以你布局的时候，完全可以按照设计师给你的效果图写各种尺寸啦。比如你在效果图上量取的某个按钮元素长 55px, 宽37px ，那你直接可以这样写样式： 1234.myBtn &#123; width: 0.55rem; height: 0.37rem;&#125; rem布局（进阶版）实践应用 为了让朋友们更清晰感受此方案的巨大优势，下面是源码和Demo实践应用1（请在手机端或者手机模式下浏览效果更佳！）实践应用2（请在手机端或者手机模式下浏览效果更佳！）示例源码常见问题说明，新手很有必要看一下1. 问：为啥手机网页效果图宽度是要640或者750的，我非得弄个666的不行咩？答：老实说当然可以，不过为了规范，640或者750是相对合适的。拿Iphone 5s 举例，它的css像素宽度是320px，由于它的dpr=2，所以它的物理像素宽度为320 × 2 = 640px，这也就是为什么，你在5s上截了一张图，在电脑上打开，它的原始宽度是640px的原因。那 iphone 6 的截图宽度呢？ 375 × 2 = 750那 iphone 6 sp 的截图宽度呢？ 414 × 3 = 1242以此类推，你现在能明白效果图为什么一般是 640 ，750 甚至是 1242 的原因了么？（真没有歧视安卓机的意思。。。） 2. 问：宽度用rem写的情况下， 在 iphone6 上没问题， 在 iphone5上会有横向滚动条，何解？答：假设你的效果图宽度是750，在这个效果图上可能有一个宽度为7rem（高清方案默认 1rem = 100px）的元素。我们知道，高清方案的特点就是几乎完美还原效果图，也就是说，你写了一个宽度为 7rem 的元素，那么在目前主流移动设备上都是7rem。然而，iphone 5 的宽度为640，也就是6.4rem。于是横向滚动条不可避免的出现了。怎么办呢？ 这是我目前推荐的比较安全的方式：如果元素的宽度超过效果图宽度的一半（效果图宽为640或750），果断使用百分比宽度，或者flex布局。就像把等屏宽的图片宽度设为100%一样。 3.问：不是 1rem = 100px吗，为什么我的代码写了一个宽度为3rem的元素，在电脑端的谷歌浏览器上宽度只有150px?答：先说高清方案代码，再次强调咱们的高清方案代码是根据设备的dpr动态设置html 的 font-size，如果dpr=1(如电脑端），则html的font-size为50px，此时 1rem = 50px如果dpr=2(如iphone 5 和 6），则html的font-size为100px，此时 1rem = 100px如果dpr=3(如iphone 6 sp），则html的font-size为150px，此时 1rem = 150px如果dpr为其他值，即便不是整数，如3.4 , 也是一样直接将dpr 乘以 50 。 再来说说效果图，一般来讲，我们的效果图宽度要么是640，要么是750，无论哪一个，它们对应设备的dpr=2，此时，1 rem = 50 × 2 = 100px。这也就是为什么高清方案默认1rem = 100px。而将1rem默认100px也是好处多多，可以帮你快速换算单位，比如在750宽度下的效果图，某元素宽度为53px，那么css宽度直接设为53/100=0.53rem了。 然而极少情况下，有设计师将效果图宽定为1242px，因为他手里只有一个iphone 6 sp (dpr = 3)，设计完效果图刚好可以在他的iphone 6 sp里查看调整。一切完毕之后，他将这个效果图交给你来切图。由于这个效果图对应设备的dpr=3，也就是1rem = 50 × 3 = 150px。所以如果你量取了一个宽度为90px的元素，它的css宽度应该为 90/150=0.6rem。由于咱们的高清方案默认1rem=100px，为了还原效果图，你需要这样换算。当然，一个技巧就是你可以直接修改咱们的高清方案的默认设置。在代码的最后 你会看到 flex(false, 100, 1) ，将其修改成flex(false, 66.66667, 1)（感谢简友：V旅行指出此处错误！ 2017/3/24）就不用那么麻烦的换算了，此时那个90px的直接写成0.9rem就可以了。 4.问：在此方案下，我如果引用了别的UI库，那些UI库的元素会显得特别小，如何解决？答：可以这样去理解问题的原因，如果不用高清方案，别的UI库的元素在移动设备上（假设这个设备是iphone 5好了）显示是正常的，这没有问题，然后我们在这个设备上将该页面截图放到电脑上看，发现宽度是640（问答1解释过了），根据你的像素眼大致测量，你发现这个设备上的某个字体大小应该是12px，而你在电脑上测量应该是24px。 现在我们使用高清方案去还原这个页面，那么字体大小应该写为 0.24rem 才对！ 所以，如果你引用了其他的UI库，为了兼容高清方案，你需要对该UI库里凡是应用px的地方做相应处理，即： a px =&gt; a*0.02 rem(具体处理方式因人而异，有模块化开发经验的同学可使用类似的 px2rem 的插件去转化，也可以完全手动处理）然而真实情况往往更为复杂，比如，你引入了百度地图（N个样式需要处理转换）；或者你引入了一个framework；又或者你使用了 video 标签，上面默认的尺寸样式很难处理。等等这些棘手问题 面对这些情况，此时我们的高清方案如果不再压缩页面，那么以上问题将迎刃而解。基于这样的思路，笔者对高清方案的源码做了如下修改，即添加一个叫做 normal 的参数，由它来控制页面是否压缩。在文章顶部代码的最后，你会看到 flex(false, 100, 1)，默认情况下页面是开启压缩的。 如果你需要禁止压缩，由于我们的源码执行后，直接将flex函数挂载到全局变量window上了，此时你直接在需要禁止压缩的页面执行 window.flex(true) 就可以了，而rem的用法保持不变。 有一点美中不足的是，如果禁止了页面压缩，高清屏的1像素就不能实现了，如果你必须要实现1像素，那么自行谷歌：css 0.5像素，有N多的解决方案，这里不再赘述。 5. 问：有时候字体会不受控制的变大，怎么办？答：在X5新内核Blink中，在排版页面的时候，会主动对字体进行放大，会检测页面中的主字体，当某一块字体在我们的判定规则中，认为字号较小，并且是页面中的主要字体，就会采取主动放大的操作。然而这不是我们想要的，可以采取给最大高度解决解决方案：*, *:before, *:after { max-height: 100000px }补充：有同学反映，在一些情况下 textarea标签内的字体大小即便加上上面的方案，字体也会变大，无法控制。此时你需要给 textarea的 display 设为 table 或者inline-table即可恢复正常。 6.问：我在底部导航用的flex感觉更合适一些，请问这样子混着用可以吗？答：咱们的rem适合写固定尺寸。其余的根据需要换成flex或者百分比。源码示例中就有这三种的综合运用。 7.问：在高清方案下，一个标准的，较为理想的宽度为640的页面效果图应该是怎样的？点击浏览：一个标准的640手机页面设计稿参考（没错，在此方案中，你可以完全按照这张设计稿的尺寸写布局了。就是这么简单！） 8.问：可以提供下这个高清方案的源码吗？12345678910111213141516171819202122232425262728293031323334&apos;use strict&apos;;/** * @param &#123;Boolean&#125; [normal = false] - 默认开启页面压缩以使页面高清; * @param &#123;Number&#125; [baseFontSize = 100] - 基础fontSize, 默认100px; * @param &#123;Number&#125; [fontscale = 1] - 有的业务希望能放大一定比例的字体; */const win = window;export default win.flex = (normal, baseFontSize, fontscale) =&gt; &#123; const _baseFontSize = baseFontSize || 100; const _fontscale = fontscale || 1; const doc = win.document; const ua = navigator.userAgent; const matches = ua.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i); const UCversion = ua.match(/U3\/((\d+|\.)&#123;5,&#125;)/i); const isUCHd = UCversion &amp;&amp; parseInt(UCversion[1].split(&apos;.&apos;).join(&apos;&apos;), 10) &gt;= 80; const isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi); let dpr = win.devicePixelRatio || 1; if (!isIos &amp;&amp; !(matches &amp;&amp; matches[1] &gt; 534) &amp;&amp; !isUCHd) &#123; // 如果非iOS, 非Android4.3以上, 非UC内核, 就不执行高清, dpr设为1; dpr = 1; &#125; const scale = normal ? 1 : 1 / dpr; let metaEl = doc.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;); if (!metaEl) &#123; metaEl = doc.createElement(&apos;meta&apos;); metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;); doc.head.appendChild(metaEl); &#125; metaEl.setAttribute(&apos;content&apos;, `width=device-width,user-scalable=no,initial-scale=$&#123;scale&#125;,maximum-scale=$&#123;scale&#125;,minimum-scale=$&#123;scale&#125;`); doc.documentElement.style.fontSize = normal ? &apos;50px&apos; : `$&#123;_baseFontSize / 2 * dpr * _fontscale&#125;px`;&#125;; 9.问：我在使用 rem 布局进阶方案的时候遇到了XXX的问题，如何解决？ 此方案久经考验，具有普遍适用性，自身出致命问题的情况很少，至少笔者是没遇到过。 绝大多数你遇到的问题，都是由于对rem布局理解不到位导致的。本文对rem布局做了大量的解释说明，配置了若干 demo，你可以把你遇到的问题放到demo里测试。遇到问题时，首先问自己，为什么这明显的错误大家没遇到就我遇到了？？ 如果你真的经过充分验证，比对，确实是rem布局自身出了问题，那么请私信我，把还原问题场景的 demo 或者文件发给我。谢谢！]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react源码浅析-入口分析]]></title>
    <url>%2F2018%2F04%2F11%2Freact%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E5%85%A5%E5%8F%A3%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[首先我们入口文件 ReactEntry.js 来看，1234var ReactBaseClasses = require(&apos;ReactBaseClasses&apos;);var ReactChildren = require(&apos;ReactChildren&apos;);var ReactElement = require(&apos;ReactElement&apos;);var ReactVersion = require(&apos;ReactVersion&apos;); var onlyChild = require(‘onlyChild’);依赖模块：• ReactBaseClasses• ReactChildren• ReactElement• onlyChild• ReactElementValidator接着: 12345678910var createElement = ReactElement.createElement;var createFactory = ReactElement.createFactory;var cloneElement = ReactElement.cloneElement;if (__DEV__) &#123; var ReactElementValidator = require(&apos;ReactElementValidator&apos;); createElement = ReactElementValidator.createElement; createFactory = ReactElementValidator.createFactory; cloneElement = ReactElementValidator.cloneElement;&#125; 可以看到在开发环境下提供了对组件的验证。12345678910111213141516171819202122232425var React = &#123; Children: &#123; map: ReactChildren.map, forEach: ReactChildren.forEach, count: ReactChildren.count, toArray: ReactChildren.toArray, only: onlyChild, &#125;, Component: ReactBaseClasses.Component, PureComponent: ReactBaseClasses.PureComponent, unstable_AsyncComponent: ReactBaseClasses.AsyncComponent, createElement: createElement, cloneElement: cloneElement, isValidElement: ReactElement.isValidElement, createFactory: createFactory, version: ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &#123; ReactCurrentOwner: require(&apos;ReactCurrentOwner&apos;), &#125;,&#125;; 上面这些就是 React 提供的所有 API 了。后续的文章会依次对这些 API 的实现进行解读。]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js htmlencode函数，主要是编辑器中反转html代码]]></title>
    <url>%2F2017%2F07%2F25%2Fjs-htmlencode%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E5%8F%8D%E8%BD%AChtml%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[主要用途是编辑器中反转html代码.用的浏览器内部转换器实现转换，要领是动态创建一个容器标签元素，如DIV，将要转换的字符串设置为这个元素的innerText(ie支持)||textContent(火狐支持)，然后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串,显示的时候反过来就可以了（实际上显示的时候不消通过转换，直接赋值在div就可以正常显示的）。 1234567891011121314151617181920212223function HTMLEncode(html) &#123; var temp = document.createElement ("div"); (temp.textContent != null) ? (temp.textContent = html) : (temp.innerText = html); var output = temp.innerHTML; temp = null; return output;&#125; function HTMLDecode(text) &#123; var temp = document.createElement("div"); temp.innerHTML = text; var output = temp.innerText || temp.textContent; temp = null; return output;&#125; var html = "&lt;br&gt;dff,哈哈、\/df&lt;p&gt;&lt;br/&gt;qqqqq&lt;/p&gt;"; var encodeHTML = HTMLEncode(html); alert("encode：" +encodeHTML); var decodeHTML = HTMLDecode(encodeHTML); alert("decode：" +decodeHTML);]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>javascript htmlencode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10招打通js任督二脉【转】]]></title>
    <url>%2F2017%2F07%2F13%2F10%E6%8B%9B%E6%89%93%E9%80%9Ajs%E4%BB%BB%E7%9D%A3%E4%BA%8C%E8%84%89%2F</url>
    <content type="text"><![CDATA[简单回调12345678910111213141516function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;function doFoo2(o)&#123; o.foo();&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "I'm an a";doFoo(obj.foo);doFoo2(obj); 分析 在Javascript中，this指向函数 执行时的当前对象，而非声明环境有。执行doFoo的时候执行环境就是doFoo函数，执行环境为全局。执行doFoo2时是在对象内部调用函数，this指针指向该对象。 结果 I&#39;m an a2 用apply改变函数作用域1234567891011121314function foo(somthing)&#123; console.log(this.a, somthing);&#125;function bind(fn, obj)&#123; return function()&#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a:2&#125;var bar = bind(foo, obj);var b = bar(3);console.log(b); 分析 apply、call、bind都有个作用就是改变作用域，这里用apply将foo函数的作用域指向obj对象，同时传入参数。 再简单分析一下bind函数内部的嵌套，执行bind函数的时候返回的是一个匿名函数，所以执行bar(3)的时候实际上是执行的bind内部的匿名函数，返回的是之前传入的foo函数的执行结果。 函数没有返回值的情况下默认返回undefined。 结果 2 3undefined new关键字123456function foo(a,b)&#123; this.val = a+b;&#125;var bar = foo.bind(null, 'p1');var baz = new bar('p2');console.log(baz.val); 分析 bind函数的第一个参数为null代表作用域不变，后面的不定参数将会和函数本身的参数按次序进行绑定，绑定之后执行函数只能从未绑定的参数开始传值。 结果 p1p2 自执行函数1234567function foo()&#123; console.log(this.a);&#125;var a = 2;var o = &#123;a:3,foo:foo&#125;;var p = &#123;a:4&#125;;(p.foo=o.foo)(); 分析 经常可以看到这样的代码123(function()&#123; //...&#125;)() 这种代码通常是创建一个立即执行的函数同时避免污染全局变量。很少有人去关注赋值语句执行之后会返回什么结果，其实就是返回当前值。也就是说当括号内执行完赋值之后，返回的是o对象中的foo函数。函数的执行环境中有一个a对象，嗯，就是它了~ 答案 2 变量属性12345var a = [];a[0] = 1;a['foobar'] = 2;console.log(a.length);console.log(a.foobar); 分析 当一个变量被声明后，扩充其属性并不会改变原数据类型。 结果 12 精度问题123var a = 'foo';a[1] = 'O';console.log(0.1+0.2==0.3||a); 分析 当操作小数时请小心，js的小数计算并不精确，所以上面的判断是false。 字符串变量是常量。 结果 foo 命名提升12345678foo();var foo = 0;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125;; 分析 声明的变量和命名函数都会被提升到代码的最前面，只不过声明的变量的赋值语句在代码中的位置不变。所以上面这段代码应该被理解为：123456789var foo;function foo()&#123; console.log(1);&#125;foo();foo = 0;foo = function()&#123; console.log(2);&#125;; 结果 1 思考12345678910foo();var foo = 0;function foo()&#123; console.log(1);&#125;foo();foo = function()&#123; console.log(2);&#125;;foo(); 上面代码的结果： 1报错 作用域1234567891011foo();var a = true;if(a)&#123; function foo()&#123; console.log('a'); &#125;&#125; else &#123; function foo()&#123; console.log('b'); &#125;&#125; 分析 javascript并不是以代码段为作用域，而是以函数。再根据命名提升的原则，所以这段代码应该是这样的：1234567891011function foo()&#123; console.log('a');&#125;function foo()&#123; console.log('b');&#125;foo();var a = true;if(a)&#123;&#125; else &#123;&#125; 结果 b 闭包陷阱12345for(var i=1;i&amp;lt;=5;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, i*1000);&#125; 分析 闭包有个重要的作用就是，在内层函数引用外层函数定义的变量时，外层函数的变量不会被会被持久化。这里有个隐藏陷阱就是for循环结束之后i仍然自增了1。 结果 66666 伪闭包123456789function foo()&#123; console.log(a);&#125;function bar () &#123; var a = 3; foo();&#125;var a = 2;bar(); 分析 闭包是函数的嵌套定义，而不是函数的嵌套调用。 结果 2 思考 如何输出3？123456789function bar () &#123; function foo()&#123; console.log(a); &#125; var a = 3; foo();&#125;var a = 2;bar();]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么整个互联网行业都缺前端工程师？]]></title>
    <url>%2F2017%2F07%2F11%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B4%E4%B8%AA%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E9%83%BD%E7%BC%BA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[现在，几乎整个互联网行业都缺前端工程师，不仅在刚起步的创业公司，对上市公司乃至巨头这个问题也一样存在。没错，优秀的前端工程师简直比大熊猫还稀少。 每天，HR群都有人在吐槽招不到前端工程师。实话说对这些需求，Betty也无能为力，因为在供不应求的前端招聘市场上，优秀的前端工程师才是有话语权的那一方。不仅在国内的互联网行业，在国外，前端工程师一样是需求旺盛、供不应求的香饽饽。 举个例子，根据indeed.com抓取的数千家网站的职位显示：目前前端的热门岗位——“HTML5”是需求增长最快的开发岗位，在所有开发职位中排名第一，MongoDB和iOS紧随其后位列第二、第三。 可见，HTML5可以说是最热门的前端岗位了，在2010年和2014年底有两次爆发性增长，现在在美国的岗位需求甚至超过了iOS。所以市场上优秀的前端工程师相对较缺少，是一个世界性难题。 原因一：前端相对来说是一个新领域，当今的web需求要求更多的工程师供应 可能很多人认为前端开发和Web开发类似，而Web开发已经有20多年的历史，所以前端并不是一个新领域。然而，前端工程师的概念中的“接口技术实现和用户体验作为一个专业的工作领域”，却无疑是很新的。大概几年前，前端开发的技术增长迅猛，如下图所示： 过去几年前端工程师的可视化增长趋势 by Google Trends 15年或更久以前，Web的可视化设计和技术实现所需要的资源是平均分配的。随着网站的发展——网站不仅是一个登录页面，工程资源的需求越来越明显。人们开始专门学习网站专用的JS、后端技术、UX、数据库，甚至系统设计。 今天，一个像AirBnB/Facebook/Quora的Web应用，投入的工程资源比设计资源多得多。换句话说，如今，做出网页的视觉设计比技术实现要更快，所以当今的web需求要求更多的工程师供应。 现在，一位合格的前端工程师，必须对视觉设计有兴趣(或者乐于做一个受虐狂▼)。 很显然，要处理大量的Web应用程序需求，技术任务就要进行分类，以便于多人同时处理网站请求。事实上现在已经不可能一个人快速地解决所有的技术细节了。 现在还有一类人是独自处理一个Web应用程序的所有问题，即”全栈工程师”，但是优秀的全栈工程师同样如大熊猫一般数量稀少。 现在，一个创业公司想要成功，几乎要覆盖一个Web应用程序的诸多技术方面：前端、后台、DBA、运营等。虽然已经有一些服务可以让企业购买登陆页面的前端模块和组件;但是如果你想要创造一些真正的Web应用程序，除了求助前端工程师，别无他法，就像你要创立一个品牌你也绕不开请一位设计师一样。 原因二：对前端，普遍存在巨大的误解，其实前端一点也不简单 大多人都认为前端开发是一个“相对于其他模块来说更简单的领域”，在他们心中的前端工程师是这样工作的： 把Photoshop文件、图片或者线框放进一个网页; 偶尔设计Photoshop文件、图片或者线框; 用JS编程，为网页制作动画、过渡效果; 用HTML和CSS编程，确定网页的内容和形式。 事实上，前端工程师在做的是： 在设计师和工程师之间创建可视化的语言; 用可视化的设计，定义一组代表内容、品牌和功能的组件; 为Web应用程序的公约、框架、需求、可视化的语言和规格设定底线; 定义Web应用程序的设备、浏览器、屏幕、动画的范围; 开发一个质量保证指南来确保品牌忠诚度、代码质量、产品标准; 为Web应用程序设定适当的行距、字体、标题、图标、余粮、填充等等; 为Web应用程序设定多种分辨率的图像，设备为主的实体模型，同时维护设计指南; 用account semantics、accessibility、SEO、schemas、microformats 标记Web应用程序; 用一种友好的，消耗小的，设备和客户端感知的方式连接API，获取内容; 开发客户端代码来显示流畅的动画、过渡、延迟加载、交互、应用工作流程，大多数时间用来考虑渐进增强和向后兼容的标准; 保证后台连接安全，采取跨地资源共享(CORS)的程序考虑，防止跨站点脚本(XSS)和跨站点请求伪造(CSRF ); 最重要的是，尽管有严格的期限、利益相关者的要求，以及设备的限制，无论现在还是将来永远是“客户第一”。 为了实现上述目标，前端工程师采用了从可视化到编程的多种工具 ，甚至有时要照顾市场、 UX 到内容tweakes等等。 原因三：大量糟糕前端工程师的存在，扰乱了市场 这或许是难以招到优秀前端工程师最明显的原因。由于前端工程师的入门门槛非常低，JS、CSS、HTML并不是很难入门掌握的语言，似乎只要花一点时间，谁都可以通过网上教程和书本学会它，前端工程师市场就是被这些浅尝辄止的家伙搞坏的。 糟糕的前端工程师是这样做事的： 滥用JS库，因为他们实际上并不了JS的内部(e.g. 一切都用jQuery); 滥用JS插件，抄别人的代码哪怕自己根本读不懂(e.g.jQuery.doParallaxPls.js); 给Web应用程序添加CSS框架，却只用到CSS/JS的5%，没有看到任何的需求、设计或者比较和评价; 认为只要添加了CSS框架，网站就可以“有求必应”; 一边在说着“响应式Web设计”，却对服务器端技术一无所知; 用CSS编程时不管预处理器、命名规范等，却用不合适的selector/ids/magic numbers等; 忽视表现、内存泄露(并不理解内存泄露的真正含义)，不会检测代码; 不会用指标衡量一个产品，或者这种指标旨在自己的电脑、浏览器、设备有效; 忽视软件技术。 要知道，入门容易精通难，计算机和软件的基础对你用JS或浏览器编程都非常重要。Web可能是最有影响力的平台和环境之一，在那里执行的程序必须被小心对待。一位优秀的前端工程师不仅要考虑Web技术和语言，并且还要了解所有不同的组件、系统和概念。 以下是优秀的前端工程师在即时面对普通的任务也会做的事情(这才是市场急需的前端)： DNS解析、使用CDN和关于multiple Hostnames as part of resources request; HTTP Headers (Expires, Cache-Control, If-Modified-Since); Steve Souders的所有规则(High Performance Websites); 如何解决PageSpeed, YSlow, Chrome Dev Tools Audit, Chrome Dev Tools Timeline显示的所有问题; 何时把任务传到服务器和客户端; 缓存，预取和负荷技术的使用; Native JS，知道何时从头开始做，何时查找别人的代码，同时可以评估这样做的优缺点; modern MVC Javascript libraries (e.g. AngularJS, EmberJS, ReactJS), graphic libraries (e.g. D3, SnapSVG), DOM manipulation libraries (e.g. jQuery, Zepto), lazy loading or package management libraries (e.g. RequireJS, CommonJS), task managers (e.g. Grunt, Gulp), package managers (e.g. Bower, Componentjs)and testing (e.g. Protractor, Selenium)的相关知识和用法; CSS标准、modern conventions、 strategies (e.g. BEM, SMACSS, OOCSS)的知识和用法; JS的电脑知识(内存管理，单线程的性质，垃圾收集算法，超时，范围，提升，模式)。 换句话说，如果说精通HTML+CSS+JS，了解后端知识，只是60分的合格前端;那么要想成为受追捧、拿高薪的80分优秀前端，要对业务需求和、架构设计有真正的运用;而100分的顶级前端，则必须要能够兼顾技术和设计，更接近“以前端开发为主的全栈工程师”了。 市场不是缺少前端，而是缺少优秀的前端工程师 现在，前端工程师终于前所未有的在Web中占有了一席之地。随着多设备、浏览器和Web标准的演变革命，前端正在成为兼顾逻辑、性能、交互、体验的综合性岗位。 虽然现在互联网行业普遍缺少前端工程师，但是我们相信越来越多的人将会加入前端的大军。不仅是因为大多数前端工作提供的优渥薪水和办公环境，也是因为Web中的前端编程变得越来越有挑战和意义。 最后，分享一组3~4月的100offer拍卖数据，给前端们鼓鼓劲： 前端工程师人均收获8.2个面试机会，已入职的前端工程师平均薪资涨幅达39%。其中，前端offer之王共收获47个offer，最高offer薪水38k*16 ，开自某土豪电商。 加油吧，前端!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启3d加速提升页面性能]]></title>
    <url>%2F2017%2F06%2F07%2F%E5%BC%80%E5%90%AF3d%E5%8A%A0%E9%80%9F%E6%8F%90%E5%8D%87%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[你知道我们可以在浏览器中用css开启硬件加速，使GPU (Graphics Processing Unit) 发挥功能，从而提升性能吗？ 现在大多数电脑的显卡都支持硬件加速。鉴于此，我们可以发挥GPU的力量，从而使我们的网站或应用表现的更为流畅。 在桌面端和移动端用CSS开启硬件加速 CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。 现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。 例如： .cube { -webkit-transform: translate3d(250px,250px,250px) rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5);}可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。 虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速 。 12345678.cube &#123; -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); transform: translateZ(0); /* Other transform properties here */&#125; 在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况： 123456789101112.cube &#123; -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden; -ms-backface-visibility: hidden; backface-visibility: hidden; -webkit-perspective: 1000; -moz-perspective: 1000; -ms-perspective: 1000; perspective: 1000; /* Other transform properties here */&#125; 在webkit内核的浏览器中，另一个行之有效的方法是 1234567.cube &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); /* Other transform properties here */&#125; 原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。 总结 只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。 小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[underscore分析]]></title>
    <url>%2F2017%2F06%2F06%2Funderscore%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[源码注释转之网上他人之备注，特收藏以后方便阅读。 // Underscore.js 1.3.3// (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.// Underscore is freely distributable under the MIT license.// Portions of Underscore are inspired or borrowed from Prototype,// Oliver Steele’s Functional, and John Resig’s Micro-Templating.// For all details and documentation:// http://documentcloud.github.com/underscore 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336(function() &#123; // 创建一个全局对象, 在浏览器中表示为window对象, 在Node.js中表示global对象 var root = this; // 保存&quot;_&quot;(下划线变量)被覆盖之前的值 // 如果出现命名冲突或考虑到规范, 可通过_.noConflict()方法恢复&quot;_&quot;被Underscore占用之前的值, 并返回Underscore对象以便重新命名 var previousUnderscore = root._; // 创建一个空的对象常量, 便于内部共享使用 var breaker = &#123;&#125;; // 将内置对象的原型链缓存在局部变量, 方便快速调用 var ArrayProto = Array.prototype, // ObjProto = Object.prototype, // FuncProto = Function.prototype; // 将内置对象原型中的常用方法缓存在局部变量, 方便快速调用 var slice = ArrayProto.slice, // unshift = ArrayProto.unshift, // toString = ObjProto.toString, // hasOwnProperty = ObjProto.hasOwnProperty; // 这里定义了一些JavaScript 1.6提供的新方法 // 如果宿主环境中支持这些方法则优先调用, 如果宿主环境中没有提供, 则会由Underscore实现 var nativeForEach = ArrayProto.forEach, // nativeMap = ArrayProto.map, // nativeReduce = ArrayProto.reduce, // nativeReduceRight = ArrayProto.reduceRight, // nativeFilter = ArrayProto.filter, // nativeEvery = ArrayProto.every, // nativeSome = ArrayProto.some, // nativeIndexOf = ArrayProto.indexOf, // nativeLastIndexOf = ArrayProto.lastIndexOf, // nativeIsArray = Array.isArray, // nativeKeys = Object.keys, // nativeBind = FuncProto.bind; // 创建对象式的调用方式, 将返回一个Underscore包装器, 包装器对象的原型中包含Underscore所有方法(类似与将DOM对象包装为一个jQuery对象) var _ = function(obj) &#123; // 所有Underscore对象在内部均通过wrapper对象进行构造 return new wrapper(obj); &#125;; // 针对不同的宿主环境, 将Undersocre的命名变量存放到不同的对象中 if( typeof exports !== &apos;undefined&apos;) &#123;// Node.js环境 if( typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; exports = module.exports = _; &#125; exports._ = _; &#125; else &#123;// 浏览器环境中Underscore的命名变量被挂在window对象中 root[&apos;_&apos;] = _; &#125; // 版本声明 _.VERSION = &apos;1.3.3&apos;; // 集合相关的方法(数据和对象的通用处理方法) // -------------------- // 迭代处理器, 对集合中每一个元素执行处理器方法 var each = _.each = _.forEach = function(obj, iterator, context) &#123; // 不处理空值 if(obj == null) return; if(nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123; // 如果宿主环境支持, 则优先调用JavaScript 1.6提供的forEach方法 obj.forEach(iterator, context); &#125; else if(obj.length === +obj.length) &#123; // 对&lt;数组&gt;中每一个元素执行处理器方法 for(var i = 0, l = obj.length; i &lt; l; i++) &#123; if( i in obj &amp;&amp; iterator.call(context, obj[i], i, obj) === breaker) return; &#125; &#125; else &#123; // 对&lt;对象&gt;中每一个元素执行处理器方法 for(var key in obj) &#123; if(_.has(obj, key)) &#123; if(iterator.call(context, obj[key], key, obj) === breaker) return; &#125; &#125; &#125; &#125;; // 迭代处理器, 与each方法的差异在于map会存储每次迭代的返回值, 并作为一个新的数组返回 _.map = _.collect = function(obj, iterator, context) &#123; // 用于存放返回值的数组 var results = []; if(obj == null) return results; // 优先调用宿主环境提供的map方法 if(nativeMap &amp;&amp; obj.map === nativeMap) return obj.map(iterator, context); // 迭代处理集合中的元素 each(obj, function(value, index, list) &#123; // 将每次迭代处理的返回值存储到results数组 results[results.length] = iterator.call(context, value, index, list); &#125;); // 返回处理结果 if(obj.length === +obj.length) results.length = obj.length; return results; &#125;; // 将集合中每个元素放入迭代处理器, 并将本次迭代的返回值作为&quot;memo&quot;传递到下一次迭代, 一般用于累计结果或连接数据 _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) &#123; // 通过参数数量检查是否存在初始值 var initial = arguments.length &gt; 2; if(obj == null) obj = []; // 优先调用宿主环境提供的reduce方法 if(nativeReduce &amp;&amp; obj.reduce === nativeReduce &amp;&amp; false) &#123; if(context) iterator = _.bind(iterator, context); return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator); &#125; // 迭代处理集合中的元素 each(obj, function(value, index, list) &#123; if(!initial) &#123; // 如果没有初始值, 则将第一个元素作为初始值; 如果被处理的是对象集合, 则默认值为第一个属性的值 memo = value; initial = true; &#125; else &#123; // 记录处理结果, 并将结果传递给下一次迭代 memo = iterator.call(context, memo, value, index, list); &#125; &#125;); if(!initial) throw new TypeError(&apos;Reduce of empty array with no initial value&apos;); return memo; &#125;; // 与reduce作用相似, 将逆向迭代集合中的元素(即从最后一个元素开始直到第一个元素) _.reduceRight = _.foldr = function(obj, iterator, memo, context) &#123; var initial = arguments.length &gt; 2; if(obj == null) obj = []; // 优先调用宿主环境提供的reduceRight方法 if(nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123; if(context) iterator = _.bind(iterator, context); return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator); &#125; // 逆转集合中的元素顺序 var reversed = _.toArray(obj).reverse(); if(context &amp;&amp; !initial) iterator = _.bind(iterator, context); // 通过reduce方法处理数据 return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator); &#125;; // 遍历集合中的元素, 返回第一个能够通过处理器验证的元素 _.find = _.detect = function(obj, iterator, context) &#123; // result存放第一个能够通过验证的元素 var result; // 通过any方法遍历数据, 并记录通过验证的元素 // (如果是在迭代中检查处理器返回状态, 这里使用each方法会更合适) any(obj, function(value, index, list) &#123; // 如果处理器返回的结果被转换为Boolean类型后值为true, 则当前记录并返回当前元素 if(iterator.call(context, value, index, list)) &#123; result = value; return true; &#125; &#125;); return result; &#125;; // 与find方法作用类似, 但filter方法会记录下集合中所有通过验证的元素 _.filter = _.select = function(obj, iterator, context) &#123; // 用于存储通过验证的元素数组 var results = []; if(obj == null) return results; // 优先调用宿主环境提供的filter方法 if(nativeFilter &amp;&amp; obj.filter === nativeFilter) return obj.filter(iterator, context); // 迭代集合中的元素, 并将通过处理器验证的元素放到数组中并返回 each(obj, function(value, index, list) &#123; if(iterator.call(context, value, index, list)) results[results.length] = value; &#125;); return results; &#125;; // 与filter方法作用相反, 即返回没有通过处理器验证的元素列表 _.reject = function(obj, iterator, context) &#123; var results = []; if(obj == null) return results; each(obj, function(value, index, list) &#123; if(!iterator.call(context, value, index, list)) results[results.length] = value; &#125;); return results; &#125;; // 如果集合中所有元素均能通过处理器验证, 则返回true _.every = _.all = function(obj, iterator, context) &#123; var result = true; if(obj == null) return result; // 优先调用宿主环境提供的every方法 if(nativeEvery &amp;&amp; obj.every === nativeEvery) return obj.every(iterator, context); // 迭代集合中的元素 each(obj, function(value, index, list) &#123; // 这里理解为 result = (result &amp;&amp; iterator.call(context, value, index, list)) // 验证处理器的结果被转换为Boolean类型后是否为true值 if(!( result = result &amp;&amp; iterator.call(context, value, index, list))) return breaker; &#125;); return !!result; &#125;; // 检查集合中任何一个元素在被转换为Boolean类型时, 是否为true值?或者通过处理器处理后, 是否值为true? var any = _.some = _.any = function(obj, iterator, context) &#123; // 如果没有指定处理器参数, 则默认的处理器函数会返回元素本身, 并在迭代时通过将元素转换为Boolean类型来判断是否为true值 iterator || ( iterator = _.identity); var result = false; if(obj == null) return result; // 优先调用宿主环境提供的some方法 if(nativeSome &amp;&amp; obj.some === nativeSome) return obj.some(iterator, context); // 迭代集合中的元素 each(obj, function(value, index, list) &#123; if(result || ( result = iterator.call(context, value, index, list))) return breaker; &#125;); return !!result; &#125;; // 检查集合中是否有值与目标参数完全匹配(同时将匹配数据类型) _.include = _.contains = function(obj, target) &#123; var found = false; if(obj == null) return found; // 优先调用宿主环境提供的Array.prototype.indexOf方法 if(nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1; // 通过any方法迭代集合中的元素, 验证元素的值和类型与目标是否完全匹配 found = any(obj, function(value) &#123; return value === target; &#125;); return found; &#125;; // 依次调用集合中所有元素的同名方法, 从第3个参数开始, 将被以此传入到元素的调用方法中 // 返回一个数组, 存储了所有方法的处理结果 _.invoke = function(obj, method) &#123; // 调用同名方法时传递的参数(从第3个参数开始) var args = slice.call(arguments, 2); // 依次调用每个元素的方法, 并将结果放入数组中返回 return _.map(obj, function(value) &#123; return (_.isFunction(method) ? method || value : value[method]).apply(value, args); &#125;); &#125;; // 遍历一个由对象列表组成的数组, 并返回每个对象中的指定属性的值列表 _.pluck = function(obj, key) &#123; // 如果某一个对象中不存在该属性, 则返回undefined return _.map(obj, function(value) &#123; return value[key]; &#125;); &#125;; // 返回集合中的最大值, 如果不存在可比较的值, 则返回undefined _.max = function(obj, iterator, context) &#123; // 如果集合是一个数组, 且没有使用处理器, 则使用Math.max获取最大值 // 一般会是在一个数组存储了一系列Number类型的数据 if(!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0]) return Math.max.apply(Math, obj); // 对于空值, 直接返回负无穷大 if(!iterator &amp;&amp; _.isEmpty(obj)) return -Infinity; // 一个临时的对象, computed用于在比较过程中存储最大值(临时的) var result = &#123; computed : -Infinity &#125;; // 迭代集合中的元素 each(obj, function(value, index, list) &#123; // 如果指定了处理器参数, 则比较的数据为处理器返回的值, 否则直接使用each遍历时的默认值 var computed = iterator ? iterator.call(context, value, index, list) : value; // 如果比较值相比上一个值要大, 则将当前值放入result.value computed &gt;= result.computed &amp;&amp; ( result = &#123; value : value, computed : computed &#125;); &#125;); // 返回最大值 return result.value; &#125;; // 返回集合中的最小值, 处理过程与max方法一致 _.min = function(obj, iterator, context) &#123; if(!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0]) return Math.min.apply(Math, obj); if(!iterator &amp;&amp; _.isEmpty(obj)) return Infinity; var result = &#123; computed : Infinity &#125;; each(obj, function(value, index, list) &#123; var computed = iterator ? iterator.call(context, value, index, list) : value; computed &lt; result.computed &amp;&amp; ( result = &#123; value : value, computed : computed &#125;); &#125;); return result.value; &#125;; // 通过随机数, 让数组无须排列 _.shuffle = function(obj) &#123; // shuffled变量存储处理过程及最终的结果数据 var shuffled = [], rand; // 迭代集合中的元素 each(obj, function(value, index, list) &#123; // 生成一个随机数, 随机数在&lt;0-当前已处理的数量&gt;之间 rand = Math.floor(Math.random() * (index + 1)); // 将已经随机得到的元素放到shuffled数组末尾 shuffled[index] = shuffled[rand]; // 在前面得到的随机数的位置插入最新值 shuffled[rand] = value; &#125;); // 返回一个数组, 该数组中存储了经过随机混排的集合元素 return shuffled; &#125;; // 对集合中元素, 按照特定的字段或值进行排列 // 相比Array.prototype.sort方法, sortBy方法支持对对象排序 _.sortBy = function(obj, val, context) &#123; // val应该是对象的一个属性, 或一个处理器函数, 如果是一个处理器, 则应该返回需要进行比较的数据 var iterator = _.isFunction(val) ? val : function(obj) &#123; return obj[val]; &#125;; // 调用顺序: _.pluck(_.map().sort()); // 调用_.map()方法遍历集合, 并将集合中的元素放到value节点, 将元素中需要进行比较的数据放到criteria属性中 // 调用sort()方法将集合中的元素按照criteria属性中的数据进行顺序排序 // 调用pluck获取排序后的对象集合并返回 return _.pluck(_.map(obj, function(value, index, list) &#123; return &#123; value : value, criteria : iterator.call(context, value, index, list) &#125;; &#125;).sort(function(left, right) &#123; var a = left.criteria, b = right.criteria; if(a === void 0) return 1; if(b === void 0) return -1; return a &lt; b ? -1 : a &gt; b ? 1 : 0; &#125;), &apos;value&apos;); &#125;; // 将集合中的元素, 按处理器返回的key分为多个数组 _.groupBy = function(obj, val) &#123; var result = &#123;&#125;; // val将被转换为进行分组的处理器函数, 如果val不是一个Function类型的数据, 则将被作为筛选元素时的key值 var iterator = _.isFunction(val) ? val : function(obj) &#123; return obj[val]; &#125;; // 迭代集合中的元素 each(obj, function(value, index) &#123; // 将处理器的返回值作为key, 并将相同的key元素放到一个新的数组 var key = iterator(value, index); (result[key] || (result[key] = [])).push(value); &#125;); // 返回已分组的数据 return result; &#125;; _.sortedIndex = function(array, obj, iterator) &#123; iterator || ( iterator = _.identity); var low = 0, high = array.length; while(low &lt; high) &#123; var mid = (low + high) &gt;&gt; 1; iterator(array[mid]) &lt; iterator(obj) ? low = mid + 1 : high = mid; &#125; return low; &#125;; // 将一个集合转换一个数组并返回 // 一般用于将arguments转换为数组, 或将对象无序集合转换为数据形式的有序集合 _.toArray = function(obj) &#123; if(!obj) return []; if(_.isArray(obj)) return slice.call(obj); // 将arguments转换为数组 if(_.isArguments(obj)) return slice.call(obj); if(obj.toArray &amp;&amp; _.isFunction(obj.toArray)) return obj.toArray(); // 将对象转换为数组, 数组中包含对象中所有属性的值列表(不包含对象原型链中的属性) return _.values(obj); &#125;; // 计算集合中元素的数量 _.size = function(obj) &#123; // 如果集合是一个数组, 则计算数组元素数量 // 如果集合是一个对象, 则计算对象中的属性数量(不包含对象原型链中的属性) return _.isArray(obj) ? obj.length : _.keys(obj).length; &#125;; // 数组相关的方法 // --------------- // 返回一个数组的第一个或順序指定的n个元素 _.first = _.head = _.take = function(array, n, guard) &#123; // 如果没有指定参数n, 则返回第一个元素 // 如果指定了n, 则返回一个新的数组, 包含顺序指定数量n个元素 // guard参数用于确定只返回第一个元素, 当guard为true时, 指定数量n无效 return (n != null) &amp;&amp; !guard ? slice.call(array, 0, n) : array[0]; &#125;; // 返回一个新数组, 包含除第一个元素外的其它元素, 或排除从最后一个元素开始向前指定n个元素 // 与first方法不同在于, first确定需要的元素在数组之前的位置, initial确定能排除的元素在数组最后的位置 _.initial = function(array, n, guard) &#123; // 如果没有传递参数n, 则默认返回除最后一个元素外的其它元素 // 如果传递参数n, 则返回从最后一个元素开始向前的n个元素外的其它元素 // guard用于确定只返回一个元素, 当guard为true时, 指定数量n无效 return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n)); &#125;; // 返回数组的最后一个或倒序指定的n个元素 _.last = function(array, n, guard) &#123; if((n != null) &amp;&amp; !guard) &#123; // 计算并指定获取的元素位置n, 直到数组末尾, 作为一个新的数组返回 return slice.call(array, Math.max(array.length - n, 0)); &#125; else &#123; // 如果没有指定数量, 或guard为true时, 只返回最后一个元素 return array[array.length - 1]; &#125; &#125;; // 获取除了第一个或指定前n个元素外的其它元素 _.rest = _.tail = function(array, index, guard) &#123; // 计算slice的第二个位置参数, 直到数组末尾 // 如果没有指定index, 或guard值为true, 则返回除第一个元素外的其它元素 // (index == null)值为true时, 作为参数传递给slice函数将被自动转换为1 return slice.call(array, (index == null) || guard ? 1 : index); &#125;; // 返回数组中所有值能被转换为true的元素, 返回一个新的数组 // 不能被转换的值包括 false, 0, &apos;&apos;, null, undefined, NaN, 这些值将被转换为false _.compact = function(array) &#123; return _.filter(array, function(value) &#123; return !!value; &#125;); &#125;; // 将一个多维数组合成为一维数组, 支持深层合并 // shallow参数用于控制合并深度, 当shallow为true时, 只合并第一层, 默认进行深层合并 _.flatten = function(array, shallow) &#123; // 迭代数组中的每一个元素, 并将返回值作为demo传递给下一次迭代 return _.reduce(array, function(memo, value) &#123; // 如果元素依然是一个数组, 进行以下判断: // - 如果不进行深层合并, 则使用Array.prototype.concat将当前数组和之前的数据进行连接 // - 如果支持深层合并, 则迭代调用flatten方法, 直到底层元素不再是数组类型 if(_.isArray(value)) return memo.concat( shallow ? value : _.flatten(value)); // 数据(value)已经处于底层, 不再是数组类型, 则将数据合并到memo中并返回 memo[memo.length] = value; return memo; &#125;, []); &#125;; // 筛选并返回当前数组中与指定数据不相等的差异数据(可参考difference方法注释) _.without = function(array) &#123; return _.difference(array, slice.call(arguments, 1)); &#125;; // 对数组中的数据进行去重(使用===进行比较) // 当isSorted参数不为false时, 将依次对数组中的元素调用include方法, 检查相同元素是否已经被添加到返回值(数组)中 // 如果调用之前确保数组中数据按顺序排列, 则可以将isSorted设为true, 它将通过与最后一个元素进行对比来排除相同值, 使用isSorted效率会高于默认的include方式 // uniq方法默认将以数组中的数据进行对比, 如果声明iterator处理器, 则会根据处理器创建一个对比数组, 比较时以该数组中的数据为准, 但最终返回的唯一数据仍然是原始数组 _.uniq = _.unique = function(array, isSorted, iterator) &#123; // 如果使用了iterator处理器, 则先将当前数组中的数据会先经过按迭代器处理, 并返回一个处理后的新数组 // 新数组用于作为比较的基准 var initial = iterator ? _.map(array, iterator) : array; // 用于记录处理结果的临时数组 var results = []; // 如果数组中只有2个值, 则不需要使用include方法进行比较, 将isSorted设置为true能提高运行效率 if(array.length &lt; 3) isSorted = true; // 使用reduce方法迭代并累加处理结果 // initial变量是需要进行比较的基准数据, 它可能是原始数组, 也可能是处理器的结果集合(如果设置过iterator) _.reduce(initial, function(memo, value, index) &#123; // 如果isSorted参数为true, 则直接使用===比较记录中的最后一个数据 // 如果isSorted参数为false, 则使用include方法与集合中的每一个数据进行对比 if( isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) &#123; // memo记录了已经比较过的无重复数据 // 根据iterator参数的状态, memo中记录的数据可能是原始数据, 也可能是处理器处理后的数据 memo.push(value); // 处理结果数组中保存的始终为原始数组中的数据 results.push(array[index]); &#125; return memo; &#125;, []); // 返回处理结果, 它只包含数组中无重复的数据 return results; &#125;; // union方法与uniq方法作用一致, 不同之处在于union允许在参数中传入多个数组 _.union = function() &#123; // union对参数中的多个数组进行浅层合并为一个数组对象传递给uniq方法进行处理 return _.uniq(_.flatten(arguments, true)); &#125;; // 获取当前数组与其它一个或多个数组的交集元素 // 从第二个参数开始为需要进行比较的一个或多个数组 _.intersection = _.intersect = function(array) &#123; // rest变量记录需要进行比较的其它数组对象 var rest = slice.call(arguments, 1); // 使用uniq方法去除当前数组中的重复数据, 避免重复计算 // 对当前数组的数据通过处理器进行过滤, 并返回符合条件(比较相同元素)的数据 return _.filter(_.uniq(array), function(item) &#123; // 使用every方法验证每一个数组中都包含了需要对比的数据 // 如果所有数组中均包含对比数据, 则全部返回true, 如果任意一个数组没有包含该元素, 则返回false return _.every(rest, function(other) &#123; // other参数存储了每一个需要进行对比的数组 // item存储了当前数组中需要进行对比的数据 // 使用indexOf方法搜索数组中是否存在该元素(可参考indexOf方法注释) return _.indexOf(other, item) &gt;= 0; &#125;); &#125;); &#125;; // 筛选并返回当前数组中与指定数据不相等的差异数据 // 该函数一般用于删除数组中指定的数据, 并得到删除后的新数组 // 该方法的作用与without相等, without方法参数形式上不允许数据被包含在数组中, 而difference方法参数形式上建议是数组(也可以和without使用相同形式的参数) _.difference = function(array) &#123; // 对第2个参数开始的所有参数, 作为一个数组进行合并(仅合并第一层, 而并非深层合并) // rest变量存储验证数据, 在本方法中用于与原数据对比 var rest = _.flatten(slice.call(arguments, 1), true); // 对合并后的数组数据进行过滤, 过滤条件是当前数组中不包含参数指定的验证数据的内容 // 将符合过滤条件的数据组合为一个新的数组并返回 return _.filter(array, function(value) &#123; return !_.include(rest, value); &#125;); &#125;; // 将每个数组的相同位置的数据作为一个新的二维数组返回, 返回的数组长度以传入参数中最大的数组长度为准, 其它数组的空白位置使用undefined填充 // zip方法应该包含多个参数, 且每个参数应该均为数组 _.zip = function() &#123; // 将参数转换为数组, 此时args是一个二维数组 var args = slice.call(arguments); // 计算每一个数组的长度, 并返回其中最大长度值 var length = _.max(_.pluck(args, &apos;length&apos;)); // 依照最大长度值创建一个新的空数组, 该数组用于存储处理结果 var results = new Array(length); // 循环最大长度, 在每次循环将调用pluck方法获取每个数组中相同位置的数据(依次从0到最后位置) // 将获取到的数据存储在一个新的数组, 放入results并返回 for(var i = 0; i &lt; length; i++) results[i] = _.pluck(args, &quot;&quot; + i); // 返回的结果是一个二维数组 return results; &#125;; // 搜索一个元素在数组中首次出现的位置, 如果元素不存在则返回 -1 // 搜索时使用 === 对元素进行匹配 _.indexOf = function(array, item, isSorted) &#123; if(array == null) return -1; var i, l; if(isSorted) &#123; i = _.sortedIndex(array, item); return array[i] === item ? i : -1; &#125; // 优先调用宿主环境提供的indexOf方法 if(nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf) return array.indexOf(item); // 循环并返回元素首次出现的位置 for( i = 0, l = array.length; i &lt; l; i++) if( i in array &amp;&amp; array[i] === item) return i; // 没有找到元素, 返回-1 return -1; &#125;; // 返回一个元素在数组中最后一次出现的位置, 如果元素不存在则返回 -1 // 搜索时使用 === 对元素进行匹配 _.lastIndexOf = function(array, item) &#123; if(array == null) return -1; // 优先调用宿主环境提供的lastIndexOf方法 if(nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item); var i = array.length; // 循环并返回元素最后出现的位置 while(i--) if( i in array &amp;&amp; array[i] === item) return i; // 没有找到元素, 返回-1 return -1; &#125;; // 根据区间和步长, 生成一系列整数, 并作为数组返回 // start参数表示最小数 // stop参数表示最大数 // step参数表示生成多个数值之间的步长值 _.range = function(start, stop, step) &#123; // 参数控制 if(arguments.length &lt;= 1) &#123; // 如果没有参数, 则start = 0, stop = 0, 在循环中不会生成任何数据, 将返回一个空数组 // 如果有1个参数, 则参数指定给stop, start = 0 stop = start || 0; start = 0; &#125; // 生成整数的步长值, 默认为1 step = arguments[2] || 1; // 根据区间和步长计算将生成的最大值 var len = Math.max(Math.ceil((stop - start) / step), 0); var idx = 0; var range = new Array(len); // 生成整数列表, 并存储到range数组 while(idx &lt; len) &#123; range[idx++] = start; start += step; &#125; // 返回列表结果 return range; &#125;; // 函数相关方法 // ------------------ // 创建一个用于设置prototype的公共函数对象 var ctor = function() &#123; &#125;; // 为一个函数绑定执行上下文, 任何情况下调用该函数, 函数中的this均指向context对象 // 绑定函数时, 可以同时给函数传递调用形参 _.bind = function bind(func, context) &#123; var bound, args; // 优先调用宿主环境提供的bind方法 if(func.bind === nativeBind &amp;&amp; nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // func参数必须是一个函数(Function)类型 if(!_.isFunction(func)) throw new TypeError; // args变量存储了bind方法第三个开始的参数列表, 每次调用时都将传递给func函数 args = slice.call(arguments, 2); return bound = function() &#123; if(!(this instanceof bound)) return func.apply(context, sargs.concat(slice.call(arguments))); ctor.prototype = func.prototype; var self = new ctor; var result = func.apply(self, args.concat(slice.call(arguments))); if(Object(result) === result) return result; return self; &#125;; &#125;; // 将指定的函数, 或对象本身的所有函数上下本绑定到对象本身, 被绑定的函数在被调用时, 上下文对象始终指向对象本身 // 该方法一般在处理对象事件时使用, 例如: // _(obj).bindAll(); // 或_(obj).bindAll(&apos;handlerClick&apos;); // document.addEventListener(&apos;click&apos;, obj.handlerClick); // 在handlerClick方法中, 上下文依然是obj对象 _.bindAll = function(obj) &#123; // 第二个参数开始表示需要绑定的函数名称 var funcs = slice.call(arguments, 1); // 如果没有指定特定的函数名称, 则默认绑定对象本身所有类型为Function的属性 if(funcs.length == 0) funcs = _.functions(obj); // 循环并将所有的函数上下本设置为obj对象本身 // each方法本身不会遍历对象原型链中的方法, 但此处的funcs列表是通过_.functions方法获取的, 它已经包含了原型链中的方法 each(funcs, function(f) &#123; obj[f] = _.bind(obj[f], obj); &#125;); return obj; &#125;; // memoize方法将返回一个函数, 该函数集成了缓存功能, 将经过计算的值缓存到局部变量并在下次调用时直接返回 // 如果计算结果是一个庞大的对象或数据, 使用时应该考虑内存占用情况 _.memoize = function(func, hasher) &#123; // 用于存储缓存结果的memo对象 var memo = &#123;&#125;; // hasher参数应该是一个function, 它用于返回一个key, 该key作为读取缓存的标识 // 如果没有指定key, 则默认使用函数的第一个参数作为key, 如果函数的第一个参数是复合数据类型, 可能会返回类似[Object object]的key, 这个key可能会造成后续计算的数据不正确 hasher || ( hasher = _.identity); // 返回一个函数, 该函数首先通过检查缓存, 再对没有缓存过的数据进行调用 return function() &#123; var key = hasher.apply(this, arguments); return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments)); &#125;; &#125;; // 延时执行一个函数 // wait单位为ms, 第3个参数开始将被依次传递给执行函数 _.delay = function(func, wait) &#123; var args = slice.call(arguments, 2); return setTimeout(function() &#123; return func.apply(null, args); &#125;, wait); &#125;; // 延迟执行函数 // JavaScript中的setTimeout会被放到一个单独的函数堆栈中执行, 执行时间是在当前堆栈中调用的函数都被执行完毕之后 // defer设置函数在1ms后执行, 目的是将func函数放到单独的堆栈中, 等待当前函数执行完成后再执行 // defer方法一般用于处理DOM操作的优先级, 实现正确的逻辑流程和更流畅的交互体验 _.defer = function(func) &#123; return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1))); &#125;; // 函数节流方法, throttle方法主要用于控制函数的执行频率, 在被控制的时间间隔内, 频繁调用函数不会被多次执行 // 在时间间隔内如果多次调用了函数, 时间隔截止时会自动调用一次, 不需要等到时间截止后再手动调用(自动调用时不会有返回值) // throttle函数一般用于处理复杂和调用频繁的函数, 通过节流控制函数的调用频率, 节省处理资源 // 例如window.onresize绑定的事件函数, 或element.onmousemove绑定的事件函数, 可以用throttle进行包装 // throttle方法返回一个函数, 该函数会自动调用func并进行节流控制 _.throttle = function(func, wait) &#123; var context, args, timeout, throttling, more, result; // whenDone变量调用了debounce方法, 因此在多次连续调用函数时, 最后一次调用会覆盖之前调用的定时器, 清除状态函数也仅会被执行一次 // whenDone函数在最后一次函数执行的时间间隔截止时调用, 清除节流和调用过程中记录的一些状态 var whenDone = _.debounce(function() &#123; more = throttling = false; &#125;, wait); // 返回一个函数, 并在函数内进行节流控制 return function() &#123; // 保存函数的执行上下文和参数 context = this; args = arguments; // later函数在上一次函数调用时间间隔截止时执行 var later = function() &#123; // 清除timeout句柄, 方便下一次函数调用 timeout = null; // more记录了在上一次调用至时间间隔截止之间, 是否重复调用了函数 // 如果重复调用了函数, 在时间间隔截止时将自动再次调用函数 if(more) func.apply(context, args); // 调用whenDone, 用于在时间间隔后清除节流状态 whenDone(); &#125;; // timeout记录了上一次函数执行的时间间隔句柄 // timeout时间间隔截止时调用later函数, later中将清除timeout, 并检查是否需要再次调用函数 if(!timeout) timeout = setTimeout(later, wait); // throttling变量记录上次调用的时间间隔是否已经结束, 即是否处于节流过程中 // throttling在每次函数调用时设为true, 表示需要进行节流, 在时间间隔截止时设置为false(在whenDone函数中实现) if(throttling) &#123; // 节流过程中进行了多次调用, 在more中记录一个状态, 表示在时间间隔截止时需要再次自动调用函数 more = true; &#125; else &#123; // 没有处于节流过程, 可能是第一次调用函数, 或已经超过上一次调用的间隔, 可以直接调用函数 result = func.apply(context, args); &#125; // 调用whenDone, 用于在时间间隔后清除节流状态 whenDone(); // throttling变量记录函数调用时的节流状态 throttling = true; // 返回调用结果 return result; &#125;; &#125;; // debounce与throttle方法类似, 用于函数节流, 它们的不同之处在于: // -- throttle关注函数的执行频率, 在指定频率内函数只会被执行一次; // -- debounce函数更关注函数执行的间隔, 即函数两次的调用时间不能小于指定时间; // 如果两次函数的执行间隔小于wait, 定时器会被清除并重新创建, 这意味着连续频繁地调用函数, 函数一直不会被执行, 直到某一次调用与上一次调用的时间不小于wait毫秒 // debounce函数一般用于控制需要一段时间之后才能执行的操作, 例如在用户输入完毕200ms后提示用户, 可以使用debounce包装一个函数, 绑定到onkeyup事件 // ---------------------------------------------------------------- // @param &#123;Function&#125; func 表示被执行的函数 // @param &#123;Number&#125; wait 表示允许的时间间隔, 在该时间范围内重复调用会被重新推迟wait毫秒 // @param &#123;Boolean&#125; immediate 表示函数调用后是否立即执行, true为立即调用, false为在时间截止时调用 // debounce方法返回一个函数, 该函数会自动调用func并进行节流控制 _.debounce = function(func, wait, immediate) &#123; // timeout用于记录函数上一次调用的执行状态(定时器句柄) // 当timeout为null时, 表示上一次调用已经结束 var timeout; // 返回一个函数, 并在函数内进行节流控制 return function() &#123; // 保持函数的上下文对象和参数 var context = this, args = arguments; var later = function() &#123; // 设置timeout为null // later函数会在允许的时间截止时被调用 // 调用该函数时, 表明上一次函数执行时间已经超过了约定的时间间隔, 此时之后再进行调用都是被允许的 timeout = null; if(!immediate) func.apply(context, args); &#125;; // 如果函数被设定为立即执行, 且上一次调用的时间间隔已经过去, 则立即调用函数 if(immediate &amp;&amp; !timeout) func.apply(context, args); // 创建一个定时器用于检查和设置函数的调用状态 // 创建定时器之前先清空上一次setTimeout句柄, 无论上一次绑定的函数是否已经被执行 // 如果本次函数在调用时, 上一次函数执行还没有开始(一般是immediate设置为false时), 则函数的执行时间会被推迟, 因此timeout句柄会被重新创建 clearTimeout(timeout); // 在允许的时间截止时调用later函数 timeout = setTimeout(later, wait); &#125;; &#125;; // 创建一个只会被执行一次的函数, 如果该函数被重复调用, 将返回第一次执行的结果 // 该函数用于获取和计算固定数据的逻辑, 如获取用户所用的浏览器类型 _.once = function(func) &#123; // ran记录函数是否被执行过 // memo记录函数最后一次执行的结果 var ran = false, memo; return function() &#123; // 如果函数已被执行过, 则直接返回第一次执行的结果 if(ran) return memo; ran = true; return memo = func.apply(this, arguments); &#125;; &#125;; // 返回一个函数, 该函数会将当前函数作为参数传递给一个包裹函数 // 在包裹函数中可以通过第一个参数调用当前函数, 并返回结果 // 一般用于多个流程处理函数的低耦合组合调用 _.wrap = function(func, wrapper) &#123; return function() &#123; // 将当前函数作为第一个参数, 传递给wrapper函数 var args = [func].concat(slice.call(arguments, 0)); // 返回wrapper函数的处理结果 return wrapper.apply(this, args); &#125;; &#125;; // 将多个函数组合到一起, 按照参数传递的顺序, 后一个函数的返回值会被一次作为参数传递给前一个函数作为参数继续处理 // _.compose(A, B, C); 等同于 A(B(C())); // 该方法的缺点在于被关联的函数处理的参数数量只能有一个, 如果需要传递多个参数, 可以通过Array或Object复合数据类型进行组装 _.compose = function() &#123; // 获取函数列表, 所有参数需均为Function类型 var funcs = arguments; // 返回一个供调用的函数句柄 return function() &#123; // 从后向前依次执行函数, 并将记录的返回值作为参数传递给前一个函数继续处理 var args = arguments; for(var i = funcs.length - 1; i &gt;= 0; i--) &#123; args = [funcs[i].apply(this, args)]; &#125; // 返回最后一次调用函数的返回值 return args[0]; &#125;; &#125;; // 返回一个函数, 该函数作为调用计数器, 当该函数被调用times次(或超过times次)后, func函数将被执行 // after方法一般用作异步的计数器, 例如在多个AJAX请求全部完成后需要执行一个函数, 则可以使用after在每个AJAX请求完成后调用 _.after = function(times, func) &#123; // 如果没有指定或指定无效次数, 则func被直接调用 if(times &lt;= 0) return func(); // 返回一个计数器函数 return function() &#123; // 每次调用计数器函数times减1, 调用times次之后执行func函数并返回func函数的返回值 if(--times &lt; 1) &#123; return func.apply(this, arguments); &#125; &#125;; &#125;; // 对象相关方法 // ---------------- // 获取一个对象的属性名列表(不包含原型链中的属性) _.keys = nativeKeys || function(obj) &#123; if(obj !== Object(obj)) throw new TypeError(&apos;Invalid object&apos;); var keys = []; // 记录并返回对象的所有属性名 for(var key in obj) if(_.has(obj, key)) keys[keys.length] = key; return keys; &#125;; // 返回一个对象中所有属性的值列表(不包含原型链中的属性) _.values = function(obj) &#123; return _.map(obj, _.identity); &#125;; // 获取一个对象中所有属性值为Function类型的key列表, 并按key名进行排序(包含原型链中的属性) _.functions = _.methods = function(obj) &#123; var names = []; for(var key in obj) &#123; if(_.isFunction(obj[key])) names.push(key); &#125; return names.sort(); &#125;; // 将一个或多个对象的属性(包含原型链中的属性), 复制到obj对象, 如果存在同名属性则覆盖 _.extend = function(obj) &#123; // each循环参数中的一个或多个对象 each(slice.call(arguments, 1), function(source) &#123; // 将对象中的全部属性复制或覆盖到obj对象 for(var prop in source) &#123; obj[prop] = source[prop]; &#125; &#125;); return obj; &#125;; // 返回一个新对象, 并从obj中复制指定的属性到新对象中 // 第2个参数开始为指定的需要复制的属性名(支持多个参数和深层数组) _.pick = function(obj) &#123; // 创建一个对象, 存放复制的指定属性 var result = &#123;&#125;; // 从第二个参数开始合并为一个存放属性名列表的数组 each(_.flatten(slice.call(arguments, 1)), function(key) &#123; // 循环属性名列表, 如果obj中存在该属性, 则将其复制到result对象 if( key in obj) result[key] = obj[key]; &#125;); // 返回复制结果 return result; &#125;; // 将obj中不存在或转换为Boolean类型后值为false的属性, 从参数中指定的一个或多个对象中复制到obj // 一般用于给对象指定默认值 _.defaults = function(obj) &#123; // 从第二个参数开始可指定多个对象, 这些对象中的属性将被依次复制到obj对象中(如果obj对象中不存在该属性的话) each(slice.call(arguments, 1), function(source) &#123; // 遍历每个对象中的所有属性 for(var prop in source) &#123; // 如果obj中不存在或属性值转换为Boolean类型后值为false, 则将属性复制到obj中 if(obj[prop] == null) obj[prop] = source[prop]; &#125; &#125;); return obj; &#125;; // 创建一个obj的副本, 返回一个新的对象, 该对象包含obj中的所有属性和值的状态 // clone函数不支持深层复制, 例如obj中的某个属性存放着一个对象, 则该对象不会被复制 // 如果obj是一个数组, 则会创建一个相同的数组对象 _.clone = function(obj) &#123; // 不支持非数组和对象类型的数据 if(!_.isObject(obj)) return obj; // 复制并返回数组或对象 return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj); &#125;; // 执行一个函数, 并将obj作为参数传递给该函数, 函数执行完毕后最终返回obj对象 // 一般在创建一个方法链的时候会使用tap方法, 例如: // _(obj).chain().tap(click).tap(mouseover).tap(mouseout); _.tap = function(obj, interceptor) &#123; interceptor(obj); return obj; &#125;; // eq函数只在isEqual方法中调用, 用于比较两个数据的值是否相等 // 与 === 不同在于, eq更关注数据的值 // 如果进行比较的是两个复合数据类型, 不仅仅比较是否来自同一个引用, 且会进行深层比较(对两个对象的结构和数据进行比较) function eq(a, b, stack) &#123; // 检查两个简单数据类型的值是否相等 // 对于复合数据类型, 如果它们来自同一个引用, 则认为其相等 // 如果被比较的值其中包含0, 则检查另一个值是否为-0, 因为 0 === -0 是成立的 // 而 1 / 0 == 1 / -0 是不成立的(1 / 0值为Infinity, 1 / -0值为-Infinity, 而Infinity不等于-Infinity) if(a === b) return a !== 0 || 1 / a == 1 / b; // 将数据转换为布尔类型后如果值为false, 将判断两个值的数据类型是否相等(因为null与undefined, false, 0, 空字符串, 在非严格比较下值是相等的) if(a == null || b == null) return a === b; // 如果进行比较的数据是一个Underscore封装的对象(具有_chain属性的对象被认为是Underscore对象) // 则将对象解封后获取本身的数据(通过_wrapped访问), 然后再对本身的数据进行比较 // 它们的关系类似与一个jQuery封装的DOM对象, 和浏览器本身创建的DOM对象 if(a._chain) a = a._wrapped; if(b._chain) b = b._wrapped; // 如果对象提供了自定义的isEqual方法(此处的isEqual方法并非Undersocre对象的isEqual方法, 因为在上一步已经对Undersocre对象进行了解封) // 则使用对象自定义的isEqual方法与另一个对象进行比较 if(a.isEqual &amp;&amp; _.isFunction(a.isEqual)) return a.isEqual(b); if(b.isEqual &amp;&amp; _.isFunction(b.isEqual)) return b.isEqual(a); // 对两个数据的数据类型进行验证 // 获取对象a的数据类型(通过Object.prototype.toString方法) var className = toString.call(a); // 如果对象a的数据类型与对象b不匹配, 则认为两个数据值也不匹配 if(className != toString.call(b)) return false; // 执行到此处, 可以确保需要比较的两个数据均为复合数据类型, 且数据类型相等 // 通过switch检查数据的数据类型, 针对不同数据类型进行不同的比较 // (此处不包括对数组和对象类型, 因为它们可能包含更深层次的数据, 将在后面进行深层比较) switch (className) &#123; case &apos;[object String]&apos;: // 如果被比较的是字符串类型(其中a的是通过new String()创建的字符串) // 则将B转换为String对象后进行匹配(这里匹配并非进行严格的数据类型检查, 因为它们并非来自同一个对象的引用) // 在调用 == 进行比较时, 会自动调用对象的toString()方法, 返回两个简单数据类型的字符串 return a == String(b); case &apos;[object Number]&apos;: // 通过+a将a转成一个Number, 如果a被转换之前与转换之后不相等, 则认为a是一个NaN类型 // 因为NaN与NaN是不相等的, 因此当a值为NaN时, 无法简单地使用a == b进行匹配, 而是用相同的方法检查b是否为NaN(即 b != +b) // 当a值是一个非NaN的数据时, 则检查a是否为0, 因为当b为-0时, 0 === -0是成立的(实际上它们在逻辑上属于两个不同的数据) return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b); case &apos;[object Date]&apos;: // 对日期类型没有使用return或break, 因此会继续执行到下一步(无论数据类型是否为Boolean类型, 因为下一步将对Boolean类型进行检查) case &apos;[object Boolean]&apos;: // 将日期或布尔类型转换为数字 // 日期类型将转换为数值类型的时间戳(无效的日期格式将被换转为NaN) // 布尔类型中, true被转换为1, false被转换为0 // 比较两个日期或布尔类型被转换为数字后是否相等 return +a == +b; case &apos;[object RegExp]&apos;: // 正则表达式类型, 通过source访问表达式的字符串形式 // 检查两个表达式的字符串形式是否相等 // 检查两个表达式的全局属性是否相同(包括g, i, m) // 如果完全相等, 则认为两个数据相等 return a.source == b.source &amp;&amp; a.global == b.global &amp;&amp; a.multiline == b.multiline &amp;&amp; a.ignoreCase == b.ignoreCase; &#125; // 当执行到此时, ab两个数据应该为类型相同的对象或数组类型 if( typeof a != &apos;object&apos; || typeof b != &apos;object&apos;) return false; // stack(堆)是在isEqual调用eq函数时内部传递的空数组, 在后面比较对象和数据的内部迭代中调用eq方法也会传递 // length记录堆的长度 var length = stack.length; while(length--) &#123; // 如果堆中的某个对象与数据a匹配, 则认为相等 if(stack[length] == a) return true; &#125; // 将数据a添加到堆中 stack.push(a); // 定义一些局部变量 var size = 0, result = true; // 通过递归深层比较对象和数组 if(className == &apos;[object Array]&apos;) &#123; // 被比较的数据为数组类型 // size记录数组的长度 // result比较两个数组的长度是否一致, 如果长度不一致, 则方法的最后将返回result(即false) size = a.length; result = size == b.length; // 如果两个数组的长度一致 if(result) &#123; // 调用eq方法对数组中的元素进行迭代比较(如果数组中包含二维数组或对象, eq方法会进行深层比较) while(size--) &#123; // 在确保两个数组都存在当前索引的元素时, 调用eq方法深层比较(将堆数据传递给eq方法) // 将比较的结果存储到result变量, 如果result为false(即在比较中得到某个元素的数据不一致), 则停止迭代 if(!( result = size in a == size in b &amp;&amp; eq(a[size], b[size], stack))) break; &#125; &#125; &#125; else &#123; // 被比较的数据为对象类型 // 如果两个对象不是同一个类的实例(通过constructor属性比较), 则认为两个对象不相等 if(&apos;constructor&apos; in a != &apos;constructor&apos; in b || a.constructor != b.constructor) return false; // 深层比较两个对象中的数据 for(var key in a) &#123; if(_.has(a, key)) &#123; // size用于记录比较过的属性数量, 因为这里遍历的是a对象的属性, 并比较b对象中该属性的数据 // 当b对象中的属性数量多余a对象时, 此处的逻辑成立, 但两个对象并不相等 size++; // 迭代调用eq方法, 深层比较两个对象中的属性值 // 将比较的结果记录到result变量, 当比较到不相等的数据时停止迭代 if(!( result = _.has(b, key) &amp;&amp; eq(a[key], b[key], stack))) break; &#125; &#125; // 深层比较完毕, 这里已经可以确保在对象a中的所有数据, 对象b中也存在相同的数据 // 根据size(对象属性长度)检查对象b中的属性数量是否与对象a相等 if(result) &#123; // 遍历对象b中的所有属性 for(key in b) &#123; // 当size已经到0时(即对象a中的属性数量已经遍历完毕), 而对象b中还存在有属性, 则对象b中的属性多于对象a if(_.has(b, key) &amp;&amp; !(size--)) break; &#125; // 当对象b中的属性多于对象a, 则认为两个对象不相等 result = !size; &#125; &#125; // 函数执行完毕时, 从堆中移除第一个数据(在比较对象或数组时, 会迭代eq方法, 堆中可能存在多个数据) stack.pop(); // 返回的result记录了最终的比较结果 return result; &#125; // 对两个数据的值进行比较(支持复合数据类型), 内部函数eq的外部方法 _.isEqual = function(a, b) &#123; return eq(a, b, []); &#125;; // 检查数据是否为空值, 包含&apos;&apos;, false, 0, null, undefined, NaN, 空数组(数组长度为0)和空对象(对象本身没有任何属性) _.isEmpty = function(obj) &#123; // obj被转换为Boolean类型后值为false if(obj == null) return true; // 检查对象或字符串长度是否为0 if(_.isArray(obj) || _.isString(obj)) return obj.length === 0; // 检查对象(使用for in循环时将首先循环对象本身的属性, 其次是原型链中的属性), 因此如果第一个属性是属于对象本身的, 那么该对象不是一个空对象 for(var key in obj) if(_.has(obj, key)) return false; // 所有数据类型均没有通过验证, 是一个空数据 return true; &#125;; // 验证对象是否是一个DOM对象 _.isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType == 1); &#125;; // 验证对象是否是一个数组类型, 优先调用宿主环境提供的isArray方法 _.isArray = nativeIsArray || function(obj) &#123; return toString.call(obj) == &apos;[object Array]&apos;; &#125;; // 验证对象是否是一个复合数据类型的对象(即非基本数据类型String, Boolean, Number, null, undefined) // 如果基本数据类型通过new进行创建, 则也属于对象类型 _.isObject = function(obj) &#123; return obj === Object(obj); &#125;; // 检查一个数据是否是一个arguments参数对象 _.isArguments = function(obj) &#123; return toString.call(obj) == &apos;[object Arguments]&apos;; &#125;; // 验证isArguments函数, 如果运行环境无法正常验证arguments类型的数据, 则重新定义isArguments方法 if(!_.isArguments(arguments)) &#123; // 对于环境无法通过toString验证arguments类型的, 则通过调用arguments独有的callee方法来进行验证 _.isArguments = function(obj) &#123; // callee是arguments的一个属性, 指向对arguments所属函数自身的引用 return !!(obj &amp;&amp; _.has(obj, &apos;callee&apos;)); &#125;; &#125; // 验证对象是否是一个函数类型 _.isFunction = function(obj) &#123; return toString.call(obj) == &apos;[object Function]&apos;; &#125;; // 验证对象是否是一个字符串类型 _.isString = function(obj) &#123; return toString.call(obj) == &apos;[object String]&apos;; &#125;; // 验证对象是否是一个数字类型 _.isNumber = function(obj) &#123; return toString.call(obj) == &apos;[object Number]&apos;; &#125;; // 检查一个数字是否为有效数字且有效范围(Number类型, 值在负无穷大 - 正无穷大之间) _.isFinite = function(obj) &#123; return _.isNumber(obj) &amp;&amp; isFinite(obj); &#125;; // 检查数据是否为NaN类型(所有数据中只有NaN与NaN不相等) _.isNaN = function(obj) &#123; return obj !== obj; &#125;; // 检查数据是否时Boolean类型 _.isBoolean = function(obj) &#123; // 支持字面量和对象形式的Boolean数据 return obj === true || obj === false || toString.call(obj) == &apos;[object Boolean]&apos;; &#125;; // 检查数据是否是一个Date类型 _.isDate = function(obj) &#123; return toString.call(obj) == &apos;[object Date]&apos;; &#125;; // 检查数据是否是一个正则表达式类型 _.isRegExp = function(obj) &#123; return toString.call(obj) == &apos;[object RegExp]&apos;; &#125;; // 检查数据是否是Null值 _.isNull = function(obj) &#123; return obj === null; &#125;; // 检查数据是否是Undefined(未定义的)值 _.isUndefined = function(obj) &#123; return obj === void 0; &#125;; // 检查一个属性是否属于对象本身, 而非原型链中 _.has = function(obj, key) &#123; return hasOwnProperty.call(obj, key); &#125;; // 工具函数 // ----------------- // 放弃_(下划线)命名的Underscore对象, 并返回Underscore对象, 一般用于避免命名冲突或规范命名方式 // 例如: // var us = _.noConflict(); // 取消_(下划线)命名, 并将Underscore对象存放于us变量中 // console.log(_); // _(下划线)已经无法再访问Underscore对象, 而恢复为Underscore定义前的值 _.noConflict = function() &#123; // previousUnderscore变量记录了Underscore定义前_(下划线)的值 root._ = previousUnderscore; return this; &#125;; // 返回与参数相同的值, 一般用于将一个数据的获取方式转换为函数获取方式(内部用于构建方法时作为默认处理器函数) _.identity = function(value) &#123; return value; &#125;; // 使指定的函数迭代执行n次(无参数) _.times = function(n, iterator, context) &#123; for(var i = 0; i &lt; n; i++) iterator.call(context, i); &#125;; // 将HTML字符串中的特殊字符转换为HTML实体, 包含 &amp; &lt; &gt; &quot; &apos; \ _.escape = function(string) &#123; return (&apos;&apos; + string).replace(/&amp;/g, &apos;&amp;&apos;).replace(/&lt;/g, &apos;&lt;&apos;).replace(/&gt;/g, &apos;&gt;&apos;).replace(/&quot;/g, &apos;&quot;&apos;).replace(/&apos;/g, &apos;&apos;&apos;).replace(/\//g, &apos;/&apos;); &#125;; // 指定一个对象的属性, 返回该属性对应的值, 如果该属性对应的是一个函数, 则会执行该函数并返回结果 _.result = function(object, property) &#123; if(object == null) return null; // 获取对象的值 var value = object[property]; // 如果值是一个函数, 则执行并返回, 否则将直接返回 return _.isFunction(value) ? value.call(object) : value; &#125;; // 添加一系列自定义方法到Underscore对象中, 用于扩展Underscore插件 _.mixin = function(obj) &#123; // obj是一个集合一系列自定义方法的对象, 此处通过each遍历对象的方法 each(_.functions(obj), function(name) &#123; // 通过addToWrapper函数将自定义方法添加到Underscore构建的对象中, 用于支持对象式调用 // 同时将方法添加到 _ 本身, 用于支持函数式调用 addToWrapper(name, _[name] = obj[name]); &#125;); &#125;; // 获取一个全局唯一标识, 标识从0开始累加 var idCounter = 0; // prefix表示标识的前缀, 如果没有指定前缀则直接返回标识, 一般用于给对象或DOM创建唯一ID _.uniqueId = function(prefix) &#123; var id = idCounter++; return prefix ? prefix + id : id; &#125;; // 定义模板的界定符号, 在template方法中使用 _.templateSettings = &#123; // JavaScript可执行代码的界定符 evaluate : /&lt;%([\s\S]+?)%&gt;/g, // 直接输出变量的界定符 interpolate : /&lt;%=([\s\S]+?)%&gt;/g, // 需要将HTML输出为字符串(将特殊符号转换为字符串形式)的界定符 escape : /&lt;%-([\s\S]+?)%&gt;/g &#125;; var noMatch = /.^/; // escapes对象记录了需要进行相互换转的特殊符号与字符串形式的对应关系, 在两者进行相互转换时作为索引使用 // 首先根据字符串形式定义特殊字符 var escapes = &#123; &apos;\\&apos; : &apos;\\&apos;, &quot;&apos;&quot; : &quot;&apos;&quot;, &apos;r&apos; : &apos;\r&apos;, &apos;n&apos; : &apos;\n&apos;, &apos;t&apos; : &apos;\t&apos;, &apos;u2028&apos; : &apos;\u2028&apos;, &apos;u2029&apos; : &apos;\u2029&apos; &#125;; // 遍历所有特殊字符字符串, 并以特殊字符作为key记录字符串形式 for(var p in escapes) escapes[escapes[p]] = p; // 定义模板中需要替换的特殊符号, 包含反斜杠, 单引号, 回车符, 换行符, 制表符, 行分隔符, 段落分隔符 // 在将字符串中的特殊符号转换为字符串形式时使用 var escaper = /\\|&apos;|\r|\n|\t|\u2028|\u2029/g; // 在将字符串形式的特殊符号进行反转(替换)时使用 var unescaper = /\\(\\|&apos;|r|n|t|u2028|u2029)/g; // 反转字符串中的特殊符号 // 在模板中涉及到需要执行的JavaScript源码, 需要进行特殊符号反转, 否则如果以HTML实体或字符串形式出现, 会抛出语法错误 var unescape = function(code) &#123; return code.replace(unescaper, function(match, escape) &#123; return escapes[escape]; &#125;); &#125;; // Underscore模板解析方法, 用于将数据填充到一个模板字符串中 // 模板解析流程: // 1. 将模板中的特殊符号转换为字符串 // 2. 解析escape形式标签, 将内容解析为HTML实体 // 3. 解析interpolate形式标签, 输出变量 // 4. 解析evaluate形式标签, 创建可执行的JavaScript代码 // 5. 生成一个处理函数, 该函数在得到数据后可直接填充到模板并返回填充后的字符串 // 6. 根据参数返回填充后的字符串或处理函数的句柄 // ------------------- // 在模板体内, 可通过argments获取2个参数, 分别为填充数据(名称为obj)和Underscore对象(名称为_) _.template = function(text, data, settings) &#123; // 模板配置, 如果没有指定配置项, 则使用templateSettings中指定的配置项 settings = _.defaults(settings || &#123;&#125;, _.templateSettings); // 开始将模板解析为可执行源码 var source = &quot;__p+=&apos;&quot; + text.replace(escaper, function(match) &#123; // 将特殊符号转移为字符串形式 return &apos;\\&apos; + escapes[match]; &#125;).replace(settings.escape || noMatch, function(match, code) &#123; // 解析escape形式标签 &lt;%- %&gt;, 将变量中包含的HTML通过_.escape函数转换为HTML实体 return &quot;&apos;+\n_.escape(&quot; + unescape(code) + &quot;)+\n&apos;&quot;; &#125;).replace(settings.interpolate || noMatch, function(match, code) &#123; // 解析interpolate形式标签 &lt;%= %&gt;, 将模板内容作为一个变量与其它字符串连接起来, 则会作为一个变量输出 return &quot;&apos;+\n(&quot; + unescape(code) + &quot;)+\n&apos;&quot;; &#125;).replace(settings.evaluate || noMatch, function(match, code) &#123; // 解析evaluate形式标签 &lt;% %&gt;, evaluate标签中存储了需要执行的JavaScript代码, 这里结束当前的字符串拼接, 并在新的一行作为JavaScript语法执行, 并将后面的内容再次作为字符串的开始, 因此evaluate标签内的JavaScript代码就能被正常执行 return &quot;&apos;;\n&quot; + unescape(code) + &quot;\n;__p+=&apos;&quot;; &#125;) + &quot;&apos;;\n&quot;; if(!settings.variable) source = &apos;with(obj||&#123;&#125;)&#123;\n&apos; + source + &apos;&#125;\n&apos;; source = &quot;var __p=&apos;&apos;;&quot; + &quot;var print=function()&#123;__p+=Array.prototype.join.call(arguments, &apos;&apos;)&#125;;\n&quot; + source + &quot;return __p;\n&quot;; // 创建一个函数, 将源码作为函数执行体, 将obj和Underscore作为参数传递给该函数 var render = new Function(settings.variable || &apos;obj&apos;, &apos;_&apos;, source); // 如果指定了模板的填充数据, 则替换模板内容, 并返回替换后的结果 if(data) return render(data, _); // 如果没有指定填充数据, 则返回一个函数, 该函数用于将接收到的数据替换到模板 // 如果在程序中会多次填充相同模板, 那么在第一次调用时建议不指定填充数据, 在获得处理函数的引用后, 再直接调用会提高运行效率 var template = function(data) &#123; return render.call(this, data, _); &#125;; // 将创建的源码字符串添加到函数对象中, 一般用于调试和测试 template.source = &apos;function(&apos; + (settings.variable || &apos;obj&apos;) + &apos;)&#123;\n&apos; + source + &apos;&#125;&apos;; // 没有指定填充数据的情况下, 返回处理函数句柄 return template; &#125;; // 支持Underscore对象的方法链操作, 可参考 wrapper.prototype.chain _.chain = function(obj) &#123; return _(obj).chain(); &#125;; // Underscore对象封装相关方法 // --------------- // 创建一个包装器, 将一些原始数据进行包装 // 所有的undersocre对象, 内部均通过wrapper函数进行构造和封装 // Underscore与wrapper的内部关系: // -内部定义变量_, 将Underscore相关的方法添加到_, 这样就可以支持函数式的调用, 如_.bind() // -内部定义wrapper类, 将_的原型对象指向wrapper类的原型 // -将Underscore相关的方法添加到wrapper原型, 创建的_对象就具备了Underscore的方法 // -将Array.prototype相关方法添加到wrapper原型, 创建的_对象就具备了Array.prototype中的方法 // -new _()时实际创建并返回了一个wrapper()对象, 并将原始数组存储到_wrapped变量, 并将原始值作为第一个参数调用对应方法 var wrapper = function(obj) &#123; // 原始数据存放在包装对象的_wrapped属性中 this._wrapped = obj; &#125;; // 将Underscore的原型对象指向wrapper的原型, 因此通过像wrapper原型中添加方法, Underscore对象也会具备同样的方法 _.prototype = wrapper.prototype; // 返回一个对象, 如果当前Underscore调用了chain()方法(即_chain属性为true), 则返回一个被包装的Underscore对象, 否则返回对象本身 // result函数用于在构造方法链时返回Underscore的包装对象 var result = function(obj, chain) &#123; return chain ? _(obj).chain() : obj; &#125;; // 将一个自定义方法添加到Underscore对象中(实际是添加到wrapper的原型中, 而Underscore对象的原型指向了wrapper的原型) var addToWrapper = function(name, func) &#123; // 向wrapper原型中添加一个name函数, 该函数调用func函数, 并支持了方法链的处理 wrapper.prototype[name] = function() &#123; // 获取func函数的参数, 并将当前的原始数据添加到第一个参数 var args = slice.call(arguments); unshift.call(args, this._wrapped); // 执行函数并返回结果, 并通过result函数对方法链进行封装, 如果当前调用了chain()方法, 则返回封装后的Underscore对象, 否则返回对象本身 return result(func.apply(_, args), this._chain); &#125;; &#125;; // 将内部定义的_(下划线, 即Underscore方法集合对象)中的方法复制到wrapper的原型链中(即Underscore的原型链中) // 这是为了在构造对象式调用的Underscore对象时, 这些对象也会具有内部定义的Underscore方法 _.mixin(_); // 将Array.prototype中的相关方法添加到Underscore对象中, 因此在封装后的Underscore对象中也可以直接调用Array.prototype中的方法 // 如: _([]).push() each([&apos;pop&apos;, &apos;push&apos;, &apos;reverse&apos;, &apos;shift&apos;, &apos;sort&apos;, &apos;splice&apos;, &apos;unshift&apos;], function(name) &#123; // 获取Array.prototype中对应方法的引用 var method = ArrayProto[name]; // 将该方法添加到Underscore对象中(实际是添加到wrapper的原型对象, 因此在创建Underscore对象时同时具备了该方法) wrapper.prototype[name] = function() &#123; // _wrapped变量中存储Underscore对象的原始值 var wrapped = this._wrapped; // 调用Array对应的方法并返回结果 method.apply(wrapped, arguments); var length = wrapped.length; if((name == &apos;shift&apos; || name == &apos;splice&apos;) &amp;&amp; length === 0) delete wrapped[0]; // 即使是对于Array中的方法, Underscore同样支持方法链操作 return result(wrapped, this._chain); &#125;; &#125;); // 作用同于上一段代码, 将数组中的一些方法添加到Underscore对象, 并支持了方法链操作 // 区别在于上一段代码所添加的函数, 均返回Array对象本身(也可能是封装后的Array), concat, join, slice方法将返回一个新的Array对象(也可能是封装后的Array) each([&apos;concat&apos;, &apos;join&apos;, &apos;slice&apos;], function(name) &#123; var method = ArrayProto[name]; wrapper.prototype[name] = function() &#123; return result(method.apply(this._wrapped, arguments), this._chain); &#125;; &#125;); // 对Underscore对象进行链式操作的声明方法 wrapper.prototype.chain = function() &#123; // this._chain用来标示当前对象是否使用链式操作 // 对于支持方法链操作的数据, 一般在具体方法中会返回一个Underscore对象, 并将原始值存放在_wrapped属性中, 也可以通过value()方法获取原始值 this._chain = true; return this; &#125;; // 返回被封装的Underscore对象的原始值(存放在_wrapped属性中) wrapper.prototype.value = function() &#123; return this._wrapped; &#125;;&#125;).call(this);]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime常用快捷键]]></title>
    <url>%2F2017%2F05%2F27%2Fsublime%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown示例【转】]]></title>
    <url>%2F2017%2F05%2F20%2Fmarkdown%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验技巧【转】]]></title>
    <url>%2F2017%2F05%2F20%2F%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhihu.com/question/36426051/answer/76031743 重构是程序员的主力技能。 工作日志能提升脑容量。 先用profiler调查，才有脸谈优化。 注释贵精不贵多。杜绝大姨妈般的“例注”。漫山遍野的碎碎念注释，实际就是背景噪音。 普通程序员+google=超级程序员。 单元测试总是合算的。 不要先写框架再写实现。最好反过来，从原型中提炼框架。 代码结构清晰，其它问题都不算事儿。 好的项目作风硬派，一键测试，一键发布，一键部署; 烂的项目生性猥琐，口口相传，不立文字，神神秘秘。 编码不要畏惧变化，要拥抱变化。 常充电。程序员只有一种死法：土死的。 编程之事，隔离是方向，起名是关键，测试是主角，调试是补充，版本控制是后悔药。 一行代码一个兵。形成建制才能有战斗力。单位规模不宜过大，千人班，万人排易成万人坑。 重构/优化/修复Bug，同时只能作一件。 简单模块注意封装，复杂模块注意分层。 人脑性能有限，整洁胜于杂乱。读不懂的代码，尝试整理下格式; 不好用的接口，尝试重新封装下。 迭代速度决定工作强度。想多快好省，就从简化开发流程，加快迭代速度开始。 忘掉优化写代码。过早优化等同恶意破坏；忘掉代码作优化。优化要基于性能测试，而不是纠结于字里行间。 最好的工具是纸笔;其次好的是markdown。 leader问任务时间，若答不上来，可能是任务拆分还不够细。 宁可多算一周，不可少估一天。过于“乐观”容易让boss受惊吓。 最有用的语言是English。其次的可能是Python。 百闻不如一见。画出结果，一目了然。调试耗时将大大缩短。 资源、代码应一道受版本管理。资源匹配错误远比代码匹配错误更难排查。 不要基于想象开发， 要基于原型开发。原型的价值是快速验证想法，帮大家节省时间。 序列化首选明文文本 。诸如二进制、混淆、加密、压缩等等有需要时再加。 编译器永远比你懂微观优化。只能向它不擅长的方向努力。 不要定过大、过远、过细的计划。即使定了也没有用。 至少半数时间将花在集成上。时间，时间，时间总是不够。 与主流意见/方法/风格/习惯相悖时，先检讨自己最可靠。出现bug主动查，不管是不是你的。这能让你业务能力猛涨、个人形象飙升; 如果你的bug被别人揪出来…..呵呵，那你会很被动～≧﹏≦ 不知怎么选技术书时就挑薄的。起码不会太贵，且你能看完。 git是最棒的。简单，可靠，免费。 仅对“可预测的非理性”抛断言。 Log要写时间与分类。并且要能重定向输出。 注释是稍差的文档。更好的是清晰的命名。让代码讲自己的故事。 造轮子是很好的锻炼方法。前提是你见过别的轮子。 code review最好以小组/结对的形式。对业务有一定了解，建议会更有价值（但不绝对）。而且不会成为负担。管理员个人review则很容易成team的瓶颈。 提问前先做调研。问不到点上既被鄙视，又浪费自己的时间。 永远别小看程序媛(╯3╰)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[饿了么基于Vue 2.0的通用组件库开发之路]]></title>
    <url>%2F2017%2F05%2F19%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E5%9F%BA%E4%BA%8EVue%202.0%E7%9A%84%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Element 是由饿了么UED设计、饿了么大前端开发的一套基于 Vue 2.0 的桌面端组件库。今天我们要分享的就是开发 Element 的一些心得。一、设计目的 大部分项目起源都是源于业务方的需求，Element 也是一样。随着公司的业务发展，内部开始衍生出很多后台系统，UED 部门也接到越来越多的设计需求。分析这整个过程，我们发现如下问题：日渐增多的后台产品设计需求 设计资源有限，没办法支持所有业务线 公司内部诸多后台产品使用体验不一致 于是我们决定：设计一套后台支撑框架，提升后台系统的可用性和一致性 套用此框架，即使没有设计师参与，也能让产品或开发设计出一套好用的后台系统二、设计阶段 下面简单说一下设计 Element 经历的几个阶段。了解业务并熟悉公司内各后台产品，寻找业务上的共性问题设计的目的是为了业务服务。第一步我们从内部系统开始入手，了解公司内部在使用的各种后台系统，将其组件抽象剥离，寻找共性特征。专注业务组件设计总结了公司不同系统不同组件的使用情况后，我们打算从业务组件入手，因为这部份是由公司特殊需求衍生的解决方案。解决了这些棘手的问题，也能给其他后台产品带来好的设计引导。寻求开发支持到这一步，我们开始寻找公司内部的开发团队，并在这时才得知不同团队里使用着不同的前端框架，有 Vue、React、Angular 等。与大前端合作大前端作为独立的前端团队，有能力开发底层的工具去服务不同业务，并且 Vue 也是一套年轻且发展方向很好的一个技术栈。UED 与大前端的合作一拍即合。方向转变，专注于基础组件跟大前端接触后，才发现最开始的方向并不正确，因为业务变化过快，即使有通用的业务组件，也很难跟上需求的变化，而基础组件才是所有开发团队都需要的通用组件。这时候我们开始把方向调整为基础组件的设计。组件交互完成，进行视觉封装，并搭建主体网站前期的设计工作主要是由交互设计师进行设计，等确认完所有组件的功能和交互后，开始进行视觉阶段，这中间包括制定颜色、字体等各类规范，也同时进行主体网站的设计。 输出 UI Kit 文件，统一设计规范 第一版网站设计，此处的「特殊组件」即业务组件。 网站二次设计第一版网站上线后视觉效果并不好，我们内部进行了调整，再次上线后就是大家现在看到的样子。 设计过程简单来说就经历了这几个阶段，如还有问题可以继续交流，下面进入开发阶段。三、开发目的 后台系统缺乏一套完整的基础组件库 Vue 在公司内部是一个比较年轻的技术栈，希望做一些基础设施的建设 提升公司在技术社区的影响力 四、开发流程 进入开发阶段后，在总体架构方面我们做了一些尝试，下面按照时间顺序分享给大家：1.如何与设计师进行配合 经过项目初期开发和设计的磨合，我们提炼了一套组件开发流程：根据交互稿和视觉稿进行开发，期间与设计师保持沟通 开发完成后自测，之后提交设计师验收 设计师提出修改意见，根据意见进行修改 完成组件开发，为网站编写例子和文档 2.如何管理多组件项目 在开发之初，我们就在思考如何降低组件的耦合度，确保组件可以独立工作。这样的目的是可以保证组件可以依赖其他组件、让用户只加载其中几个组件甚至在安装时只安装需要的组件。最先想到的做法是一个组件单独一个仓库，而组件库项目就是把组件作为依赖引入。但是由于人手不足，这样的机制导致开发太耗时间，每个组件都需要单独维护和打包，同时还要维护组件库项目的各依赖的版本号。我们只能另寻方案。后来参考了 babel 项目的管理方式：所有子项目放在 packages/目录里，一个子项目可以当作一个独立的仓库。通过 lerna 来管理子项目的依赖和发布。结合自身项目的特点以及 babel 的这套机制，我们重构了目录结构：组件可单独作为一个项目放在 packages/，共用函数放在 src/里。最后的打包结果会将整个组件打包成一个文件、组件分别打包成独立文件，同时发布时还将发布组件库和独立组件，满足不同用户的使用需求。 3.如何解决自定义主题 开发一套组件库就离不开定制主题的需求。类名要足够友好，尽量避免存在样式层级嵌套，这样在直接覆盖样式或者单独写一套主题都会方便许多。所以我们采用 BEM 的方式管理类名，同时尽可能将属性值用变量代替，维护一份变量文件便于直接修改变量就能定制一套主题。考虑到不同用户的使用习惯，我们没有选用 Less 或 Sass 之类的有各自风格的预处理器，而是选用了更接近未来标准的 CSS4 风格的语法，用 PostCSS 和整合了 postcss-bem 和 postcss-cssnext 等插件的 postcss-salad 开发。为了降低用户自定义主题的上手成本，我们还提供了命令行工具指导用户快速自定义一套主题。4.如何提供一份直观的文档 文档不仅是让用户看起来直观，也要让编写者写起来直观。所以最简单的方式是用 Markdown 写文档。但是就会产生另一个问题：如何在文档里写可运行的示例？常规的做法是把文档写在 Vue 文件里，这样就可以在里面调用其他组件，但是这样就违背了写「直观」文档的初衷。经过几番尝试，结合 Vue 的特点。我们写了一套处理 Markdown 文件的 webpack loader，可以将 Markdown 转成 Vue 文件，不仅降低了文档的维护成本，同时也将文档里运行组件示例变成可能。5.多语言官网如何配置和管理 Element 在立项之初其实并没有考虑国际化的问题。项目开源之后，我们陆续收到了一些外国开发者的反馈，希望能够增加英文文档。不久之后，国内的一个翻译团队主动联系到了我们，为 Element 贡献了整套英文文档。有了英文文档就需要有英文网站，这就需要对官网的现有结构进行修改和升级；同时为了面向未来，需要官网能够兼容除英语外的其他多语言。为此我们做了以下工作：（1）路由官网的路由是根据一个记录了导航信息的 json文件自动生成的。因此需要在这个 json文件中添加对应于其他语言的字段，并且根据新的数据结构修改路由生成的逻辑。（2）页面官网中除了文档外，还有一些介绍性质的页面。这些页面中文字比较多，如果人工管理每种语言的页面，若需要修改则必须去每个页面相应的位置进行编辑，有些繁琐。我们的做法是：每个页面对应一个模板，模板中的文字全部抽取到一个语言配置文件中，并且写了一个脚本生成最终的页面。这样在需要修改时，只需在语言配置文件中编辑对应的字段即可。（3）网站组件对于 header、footer等通用的页面组件，我们采取了和上面类似的策略。但由于组件内的文字较少，于是没有再使用模板，而是通过路由判断应该显示何种语言。 中英文网站的显示效果 至此，我们也逐渐完善了技术栈。用 ES2015 和 CSS4 作开发语言、Lerna 负责管理组件、用 Karma 搭配 Mocha 和 Chai 等工具在 Travis CI 里做持续集成测试，最后用 Markdown 结合 Vue 写文档。我们甚至还在 CI 里实现了自动部署网站和推送主题仓库代码等功能，提升了不少开发效率。 6.开发过程中遇到的问题 具体到组件层面，在开发的过程中不可避免地会遇到一些问题。下面是我们的一些应对策略，希望能够抛砖引玉，引发大家的思考和讨论。如何应对父子组件间事件派发机制的改变在 Vue 2.0 中，用于父子组件间事件通信的 $dispatch和 $broadcast被移除了。官方的考虑是，基于组件树结构的事件流方式让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。但是类似 Element 这样的组件库有几个特点：首先，父子组件间互相通信的场景非常常见，比如在一个带有验证功能的表单里，每个表单项在 change或 blur时需要通知表单组件进行校验；其次，组件的结构相对来说比较固定。出于以上考虑，我们实现了简化版的 dispatch和 broadcast，并把它们包装成了一个 mixin，方便在需要时调用。其中的 dispatch代码如下：dispatch(componentName, eventName, params) { var parent = this.$parent || this.$root; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) { parent = parent.$parent; if (parent) { name = parent.$options.componentName; } } if (parent) { parent.$emit.apply(parent, [eventName].concat(params)); } } 可以看出，我们的实现需要在调用时传入 componentName（在各个组件中定义），这样就确保了事件只会在正确的组件中触发。是否需要为用户代理自定义组件上的原生事件在 Vue 2.0 中的自定义组件上使用 v-on只会监听自定义事件（即组件用 $emit触发的事件）。如果要监听原生事件，必须使用 .native修饰符： 这样一来，很多不太熟悉 Vue 2.0 语法的用户会发现给 Element 的组件绑定原生事件总是不生效。事实上，我们从开源以来收到的 issue 里被问得最多的一个问题是：如何给 Button组件绑定 click事件？事实上我们只需要添加一行代码就能解决问题，但是关于是否需要让用户可以直接监听原生事件这件事在我们内部有两种不同的观点：一边认为应该遵循 Vue 的设计思想，原生事件要加 native；另一边认为 button 最常用的就是 click 事件，帮助用户做这件事可以降低学习成本。后来我们专门咨询了尤雨溪本人，他的观点是，对于一些组件的常用事件，可以允许用户直接监听原生事件，同时在文档中说明哪些事件可以直接监听，哪些事件需要加 .native修饰符。最后我们决定从易用性的角度出发，让用户在使用 Button组件时可以监听原生 click事件，因为对于桌面端来说，Button在绝大部分场景下都是需要监听点击事件的。 现在的 Button支持以下两种写法： Click Me! Click Me! 版本迭代的过程中，若 API 发生变化，如何友好地提示用户在历次迭代中，我们会尽量保持 API 的一致。但是在一些万不得已的情况下，需要对 API 作出一些更新。对于老版本的用户而言，如果使用了被移除的 API，升级到新版后会出现一些意料之外的报错信息。为了友好地帮助用户尽快找到报错的来源，我们编写了一个 mixin，当组件的 API 发生变化时，在组件中引入这个 mixin并列出变化前后的字段名即可。mixin的核心代码为：const { props, events } = this.getMigratingConfig(); const { data, componentOptions } = this.$vnode; const definedProps = data.attrs || {}; const definedEvents = componentOptions.listeners || {}; for (let propName in definedProps) { if (definedProps.hasOwnProperty(propName) &amp;&amp; props[propName]) { console.warn([Element Migrating][Attribute]: ${props[propName]}); } } for (let eventName in definedEvents) { if (definedEvents.hasOwnProperty(eventName) &amp;&amp; events[eventName]) { console.warn([Element Migrating][Event]: ${events[eventName]}); } } 引用了这个 mixin的组件需要在 methods中添加一个名为 getMigratingConfig的方法，返回一个包含发生变化的 API 字段名和对应提示信息的对象：getMigratingConfig() { return { props: { ‘selection-mode’: ‘Table: selection-mode has been removed.’ }, events: { cellclick: ‘Table: cellclick has been renamed to cell-click.’ } }; } 五、issue 处理方式 我们选择使用 Tower 来配合 GitHub 进行 issue 的追踪和处理。首先在 Tower 上建立几个清单：Plan、Design、Develop 和 Release。随后具体的操作流程如下：从各渠道收集反馈 若不需设计，则由开发回复 若需设计跟进，则在 GitHub 上添加标签 design，并在 Tower 的 Plan 清单中添加相应任务 开始处理任务后，为 GitHub 的对应 issue 添加 working in progress标签，同时把任务拖进 Tower 的 Design 清单 设计完成后，开发接手，同时把任务拖进 Develop 清单 开发完成，经过设计师验收通过后将改动推送至 GitHub 仓库，关闭相应 issue，最后将任务拖进 Release 清单 六、总结 Element 从立项至今已经走过了五个月的时间。总的来说，这段时间就是一个不断发现问题和解决问题的过程，也是每个参与者自身成长的过程。开发时 Vue 2.0 正处于 RC 阶段，我们随着它的版本迭代踩到了不少坑，同时也给 Vue 提了一些 issue，并且都得到了 Vue 团队的处理。在此向Vue 团队的专业精神表示感谢。自从 9 月开源以来，在社区的帮助下，Element 逐渐成熟，我们也在今天发布了它的第一个正式版本。希望越来越多的人能够参与进来，和我们一起把 Element 做得更好。七、参考资料 https://github.com/babel/babel https://github.com/lerna/lerna https://github.com/ElemeFE/postcss-salad https://github.com/QingWei-Li/vue-markdown-loader https://github.com/ElemeFE/cooking 精彩问答 淀粉提问：Element官网是多少？Element开发团队：官网是 http://element.eleme.io淀粉提问：如何修改样式？Element开发团队：简单的样式可以通过覆盖来修改；对于大规模的自定义，我们提供了一套自定义主题的工具，文档看这里：https://github.com/ElemeFE/element/blob/master/custom-theme.md 。简单来说，通过修改样式变量、编译主题、引入主题，就可以实现自定义主题。淀粉提问：Vue的作者给出了一套学习Vue路径，那Element是否有阅读源码的路径呢，怎么样才可以较为方便的理解源码，并且在基础组件不能满足自己业务的时候写出自己的组件呢？Element开发团队：阅读源码的话，可以先 clone 项目后，先试试用 npm run new 指令创建一个新组件，看看我们的一个组件包含了哪些东西。要理解源码的话就自己边改代码边测试效果吧。淀粉提问：怎么看待Vue添加redux,而又保留双向绑定的数据方式？Element开发团队：不太明白想问什么。淀粉提问：国际化网站怎么做的，是每种语言对应一个页面吗，还是统一的一个页面？Element开发团队：Element 的主页是一个 SPA，每种语言对应了一个 .vue 文件，而这些 .vue 文件是通过一个统一的模板和语言配置文件生成出来的。淀粉提问：请问会推出专门针对移动端的Vue2组件库吗？Element开发团队：目前没有将 Element 移植到移动端的计划。不过，我们已经有一套移动端组件库了：https://github.com/ElemeFE/mint-ui ，它有两个版本，分别兼容 Vue 1.x 和 2.0。淀粉提问：写在 Vue 文件中的 MarkDown 输出在哪里？这并不是显示效果的一部分呀？Element开发团队：Vue 和 MarkDown 的结合，我们是自己做了一个 vue-markdown-loader, 作用是将 MarkDown 文件转成 Vue 组件（生成的文件在插件的 .cache 目录里），最后通过 vue-loader 处理。可以去看看这个 loader 的源码就明白了。淀粉提问：既然是基于Vue了，那么Element还有继续的必要吗？而且目前框架那么多，Vue也得到了人的认可。Element以后得生态如何保证？毕竟还只有目前饿了么一个团队在用。Element开发团队：不太清楚“Element还有继续的必要”是什么意思，据我们在 Gitter 对用户的了解，现在已经有不少用户将 Element 实用到他们公司的产品开发里。Element 的生态发展除了我们团队本身以外还需要依靠开源的力量来进行优化和发展。淀粉提问：在组件开发中,有对复用性很高的业务组件做过积累吗？如果做过～是怎么维护这些业务组件的？也是同逻辑组件的维护方法一样吗？Element开发团队：组件开发中会不断收到各种的功能需求的反馈，通过 GitHub 仓库 issue 来推动我们组件的功能更新和维护。不太清楚“逻辑组件”的含义，Element 里除了按钮这样特殊的组件外都是带有逻辑的。淀粉提问：请问将常见的jq插件或者说jq动效写成Vue组件的过程中有什么不顺畅的地方吗？Element开发团队：在组件开发过程中没有参考任何 jq 插件的动效。实际上基于 mvvm 框架下的组件库开发相对于 jq 是轻松很多的，因为你不需要手动地处理事件绑定和视图的更新。淀粉提问：分享的文档是否有些陈旧没有更新，Vue 目前已经不是 RC阶段了。Element开发团队：文档中说「开发时」Vue 还处于 RC 阶段，主要指的是今年的八九月份，那时 Vue 每更新一个 RC 版本，我们就跟着做一遍测试，然后发现几个 bug 的情景还历历在目。Vue 2.0 是上个月正式发布的，我们也在今天发布了 Element 的正式版。淀粉提问：有没有模板可以参考？Element开发团队：有，看这里：https://github.com/ElementUI/element-starter。如果熟悉 cooking 或 laravel，我们也提供了相应的模板：https://github.com/ElementUI/element-cooking-starter 、 https://github.com/ElementUI/element-in-laravel-starter 。淀粉提问：Element的开发者都是饿了么前端团队的吗，团队外的开发者占多少？Element开发团队：是的。不过自从 Element 开源以来，社区出现了一批热心用户，他们也贡献了自己的代码。所有贡献者可以从这里看到：https://github.com/ElemeFE/element/graphs/contributors 。淀粉提问：几年前，不计算Gzip 90kb的jQuery遭到了人们的嫌弃：太大了，还是用原生吧。 几年后，开启Gzip后 仍有300kb的基于React的项目，人们觉得：区区300kb而已，算很小了。巨型库的概念流行后，人们似乎忘了啪啪啪在脸上有多疼。你怎么看？Element开发团队：这几年网速已经提升不少，同时前端项目的复杂度也变得越来越高。比起库的体积，可能现在开发效率才是开发者所关心的。淀粉提问：Element这套组件和Ant Design感觉有点类似，是否有借鉴过他们的设计？Element开发团队：有借鉴过，我们不仅借鉴过 AntDesign，国内外大大小小的 Design Language 都有借鉴学习。很多信息前人已经总结过，我们希望可以快速的获得这些知识，以便更快的走到前方去探索更前沿的设计。淀粉提问：感谢分享。目前有没有优秀应用案例可以分享？Element开发团队：目前我们还没有精力去收集整理使用了 Element 的项目，不过按照最近一段时间在 Gitter 里讨论看到了一些开发者分享的项目链接，完成质量还是挺高的。过段时间我们会在 issue 里开始征集大家使用 Element 组件库的作品链接做分享。淀粉提问：如何定制CSS，是覆盖还是改源码？改了源码如果Element版本更新之后 样式就没了？Element开发团队：可以用 element-theme 主题自定义工具，或者直接下载 element-theme-default 主题包自己修改主题。如果只是简单的修改，建议直接覆盖样式。淀粉提问：您好，我是个初学者，看不大懂编程，初学要做前端，应该先从哪开始入手学习？Element开发团队：freecodecamp 和 codecademy 都是很好的入门途径。淀粉提问：在技术选型的时候，基于什么考虑，选择了Vue，而不是React？Element开发团队：和 React 相比，我们公司前端使用 Vue 的更多。为了照顾到大多数人，我们选用 Vue 作为 Element 的框架。淀粉提问：我在写 Vue 的组件通信中，也发现事件比较好用但不容易被控制，因此一般是给自定义事件加上命名空间，如 “$dispatch(‘AComponent::rotate’, 90)，”Element 团队有这样的实践吗？Element开发团队：在 Element 的组件中对组件通信这一块并没有用到全局的 event bug，而是通过dispatch和broadcast来进行相互依赖的组件间的通信。虽然Vue2.0里弃用了$dispatch和$broadcast的api，但我们自己在组件库中封装了一遍。淀粉提问：Element 团队使用 Vuex 时的一些具体情景是什么？Element开发团队： Element 没有用到 Vuex 的情景。淀粉提问：后续是否会开放一些常见业务组件，比如城市选择等？Element开发团队：与后台业务关联很大的组件应该不会直接开放，不过这个组件如果能解决类似的其他问题，我们会抽离业务属性将之作为「基础组件」开放出来。城市选择只用了比较基础的 Select 组合而已。淀粉提问：Element 在做动画效果这个方向上有些什么成绩呢？Element开发团队：动画效果方面我们还没有人力去探索和研究，主要精力还是放在业务系统的搭建上。嘉宾简介 Element 开发团队照片从左到右依次为：FuryBean、cinwell、杨奕、曾海平、敖天羽、Fishpaw、Fredddli、梓非徐 Element 开发团队由饿了么 UED 的设计师和大前端的工程师组成，他们协作开发了 Element ——一套基于 Vue 2.0 的桌面端组件库。今日荐文 Vue相关内容推荐：Vue作者尤雨溪：Vue 2.0，渐进式前端解决方案Vue 2.0 快速上手指南 更轻更快的Vue.js 2.0与其他框架对比 Vue.js作者尤雨溪加盟Weex项目担任技术顾问]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2017%2F05%2F17%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[更改档案拥有者命令 : chown [-cfhvR] [--help] [--version] user[:group] file... 功能 : 更改文件或者文件夹的拥有者 参数格式 : user : 新的档案拥有者的使用者 IDgroup : 新的档案拥有者的使用者群体(group) -c : 若该档案拥有者确实已经更改，才显示其更改动作 -f : 若该档案拥有者无法被更改也不要显示错误讯息 -h : 只对于连结(link)进行变更，而非该 link 真正指向的档案 -v : 显示拥有者变更的详细资料 -R : 对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更) 例如：chown -R oracle:oinstall /oracle/u01/app/oracle 更改目录拥有者为oracle 修改权限命令：chmod (change mode) 功能：改变文件的读写和执行权限。有符号法和八进制数字法。 选项：(1)符号法： 命令格式：chmod {u|g|o|a}{+|-|=}{r|w|x} filename u (user) 表示用户本人。 g (group) 表示同组用户。 o (oher) 表示其他用户。 a (all) 表示所有用户。 + 用于给予指定用户的许可权限。 - 用于取消指定用户的许可权限。 = 将所许可的权限赋给文件。 r (read) 读许可，表示可以拷贝该文件或目录的内容。 w (write) 写许可，表示可以修改该文件或目录的内容。 x (execute)执行许可，表示可以执行该文件或进入目录。 (2)八进制数字法： 命令格式：chmod abc file 其中a,b,c各为一个八进制数字，分别表示User、Group、及Other的权限。 4 (100) 表示可读。 2 (010) 表示可写。 1 (001) 表示可执行。 若要rwx属性则4+2+1=7； 若要rw-属性则4+2=6； 若要r-x属性则4+1=5。 例如：# chmod a+rx filename 让所有用户可以读和执行文件filename。 # chmod go-rx filename 取消同组和其他用户的读和执行文件filename的权限。 # chmod 741 filename 让本人可读写执行、同组用户可读、其他用户可执行文件filename。 # chmod -R 755 /home/oracle 递归更改目录权限，本人可读写执行、同组用户可读可执行、其他用户可读可执行 修改文件日期命令：touch 格式：touch filenae 功能：改变文件的日期，不对文件的内容做改动，若文件不存在则建立新文件。 例如：% touch file 链接文件命令：ln (link) 格式：ln [option] filename linkname ln [option] directory pathname 功能：为文件或目录建立一个链。其中，filename和directory是源文件名和 源目录名；linkname和pathname分别表示与源文件或源目录名相链接的 文件或目录。 选项：-s 为文件或目录建立符号链接。不加-s表示为文件或目录建立硬链接 注释：链接的目地在于，对一个文件或目录赋予两个以上的名字，使其可以出 现在不同的目录中，既可以使文件或目录共享，又可以节省磁盘空间。 例如：% ln -s filename linkname 显示日期命令：date 例如：% date 显示日历命令：cal (calendar) 格式：cal [month] year 功能：显示某年内指定的日历 例如：% cal 1998 显示文件头部命令：head 格式：head [option] filename 功能：显示文件的头部 选项：缺省 显示文件的头10行。 -i 显示文件的开始 i行。 例如：% head filename 显示文件尾部命令：tail 格式：tail [option] filename 功能：显示文件的尾部 选项：缺省 显示文件的末10行。 -i 显示文件最后 i行。 +i 从文件的第i行开始显示。 例如：% tail filename 显示用户标识命令：id 格式：id [option] [user] 功能：显示用户标识及用户所属的所有组。 选项：-a 显示用户名、用户标识及用户所属的所有组 注释： 例如：% id username 查看当前登录的用户命令：users 显示都谁登录到机器上命令：who 格式：who 功能：显示当前正在系统中的所有用户名字，使用终端设备号，注册时间。 例如：% who 显示当前终端上的用户名命令：whoami 格式：whoami 功能：显示出当前终端上使用的用户。 例如：% whoami 寻找文件命令：find 格式：find pathname [option] expression 功能：在所给的路经名下寻找符合表达式相匹配的文件。 选项：-name 表示文件名 -user 用户名，选取该用户所属的文件 -size 按大小查找，以block为单位，一个block是512B -mtime n 按最后一次修改时间查找，选取n天内被修改的文件 -perm 按权限查找 -type 按文件类型查找 -atime 按最后一次访问时间查找 例如：% find ./ -name &apos;*abc*&apos; -print 搜索文件中匹配符命令：grep 格式：grep [option] pattern filenames 功能：逐行搜索所指定的文件或标准输入，并显示匹配模式的每一行。 选项：-i 匹配时忽略大小写 -v 找出模式失配的行 例如：% grep -i &apos;java*&apos; ./test/run.sh 统计文件字数命令：wc [option] filename 功能：统计文件中的文件行数、字数和字符数。 选项：-l 统计文件的行数 -w 统计文件的单词数 -c 统计文件的字符数 注释：若缺省文件名则指标准输入 例如：% wc -c ./test/run.sh 显示磁盘空间命令：df (disk free) 格式：df [option] 功能：显示磁盘空间的使用情况，包括文件系统安装的目录名、块设备名、总 字节数、已用字节数、剩余字节数占用百分比。 选项： -a：显示全部的档案系统和各分割区的磁盘使用情形 -i：显示i -nodes的使用量 -k：大小用k来表示 (默认值) -t：显示某一个档案系统的所有分割区磁盘使用量 -x：显示不是某一个档案系统的所有分割区磁盘使用量 -T：显示每个分割区所属的档案系统名称 -h: 表示使用「Human-readable」的输出，也就是在档案系统大小使用 GB、MB 等易读的格式。 注释： 例如：% df -hi 查询档案或目录的磁盘使用空间命令：du (disk usage) 格式：du [option] [filename] 功能：以指定的目录下的子目录为单位，显示每个目录内所有档案所占用的磁盘空间大小 选项： -a：显示全部目录和其次目录下的每个档案所占的磁盘空间 -b：大小用bytes来表示 (默认值为k bytes) -c：最后再加上总计 (默认值) -s：只显示各档案大小的总合 -x：只计算同属同一个档案系统的档案 -L：计算所有的档案大小 -h: 表示档案系统大小使用 GB、MB 等易读的格式。 例如：% du -a % du -sh /etc 只显示该目录的总合 % du /etc | sort -nr | more 统计结果用sort 指令进行排序,sort 的参数 -nr 表示要以数字排序法进行反向排序。 显示进程命令：ps 格式：ps [option] 功能：显示系统中进程的信息。包括进程ID、控制进程终端、执行时间和命令。 选项： -a 显示所有进程信息 -U uidlist 列出这个用户的所有进程 e 显示当前运行的每一个进程信息 -f 显示一个完整的列表 -x 显示包括没有终端控制的进程状况 。 注释： 例如：% ps -ef % ps -aux 然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。 终止进程命令：kill 格式：kill [option] pid 功能：向指定的进程送信号或终止进程。kill指令的用途是送一个signal给某一个process， 因为大部份送的都是用来杀掉 process 的 SIGKILL 或 SIGHUP ，因此称为 kill 选项：-9 强行终止进程 注释：pid标示进程号，可由ps命令得到。 例如：% kill -9 pid 你也可以用 kill -l 来察看可代替 signal 号码的数目字。kill 的详细情形请参阅 man kill。 查看自己的IP地址命令：ifconfig 格式：ifconfig -a 查看路由表命令：netstat 格式：netstat -rn 远程登录命令：telnet 格式：telnet hostname 文件传输命令：ftp (file transfer program) 格式：ftp hostname 功能：网络文件传输及远程操作。 选项：ftp命令： cd [dirname] 进入远程机的目录 lcd [dirname] 设置本地机的目录 dir/ls 显示远程的目录文件 bin 以二进制方式进行传输 asc 以文本文件方式进行传输 get/mget 从远程机取一个或多个文件 put/mput 向远程机送一个或多个文件 prompt 打开或关闭多个文件传送时的交互提示 close 关闭与远程机的连接 quit 退出ftp !/exit ftp登陆状态下，!表示暂时退出ftp状态回到本地目录，exit表示返回ftp状态 注释： 例如：% ftp hostname 查看自己的电子邮件命令：mailx 格式：mailx 选项： delete 删除 next 下一个 quit 退出 reply 回复 回忆命令命令：history 格式：history 功能：帮助用户回忆执行过的命令。 选项： 注释： 例如：% history 网上对话命令：talk 格式：talk username 功能：在网上与另一用户进行对话。 选项： 注释：对话时系统把终端分为上下两部分，上半部显示自己键入信息，下半部 显示对方用户键入的信息。键入delete或Ctrl+C则结束对话。 例如：% talk username 允许或拒绝接受信息命令：mesg (message) 格式：mesg [n/y] 功能：允许或拒绝其它用户向自己所用的终端发送信息。 选项：n 拒绝其它用户向自己所用的终端写信息 y 允许其它用户向自己所用的终端写信息（缺省值） 注释： 例如：% mesg n 给其他用户写信息命令：write 格式：write username [ttyname] 功能：给其他用户的终端写信息。 选项： 注释：若对方没有拒绝，两用户可进行交谈，键入EOF或Ctrl+C则结束对话。 例如：write username 创建、修改、删除用户和群组a. 创建群组： 例如： groupadd oinstall 创建群组名为oinstall的组 groupadd -g 344 dba 创建组号是344的组，此时在/etc/passwd文件中产生一个组ID（GID）是344的项目。 b. 修改群组： groupmod:该命令用于改变用户组帐号的属性 groupmod –g 新的GID 用户组帐号名 groupmod –n 新组名 原组名：此命令由于改变用户组的名称 c. 删除群组： groupdel 组名：该命令用于删除指定的组帐号 d. 新建用户： 命令： useradd [－d home] [－s shell] [－c comment] [－m [－k template]] [－f inactive] [－e expire ] [－p passwd] [－r] name 主要参数 -c：加上备注文字，备注文字保存在passwd的备注栏中。 -d：指定用户登入时的启始目录。 -D：变更预设值。 -e：指定账号的有效期限，缺省表示永久有效。 -f：指定在密码过期后多少天即关闭该账号。 -g：指定用户所属的群组。 -G：指定用户所属的附加群组。 -m：自动建立用户的登入目录。 -M：不要自动建立用户的登入目录。 -n：取消建立以用户名称为名的群组。 -r：建立系统账号。 -s：指定用户登入后所使用的shell。 -u：指定用户ID号。 举例： # useradd -g oinstall -G dba oracle 创建Oracle用户 e. 删除用户 命令： userdel 用户名 删除指定的用户帐号 userdel –r 用户名(userdel 用户名;rm 用户名)：删除指定的用户帐号及宿主目录 例：#useradd -g root kkk //把kkk用户加入root组里 f. 修改用户 命令： usermod 修改已有用户的信息 usermod –l 旧用户名 新用户名： 修改用户名 usermod –L 用户名： 用于锁定指定用户账号，使其不能登陆系统 usermod –U 用户名： 对锁定的用户帐号进行解锁 passwd –d 用户名： 使帐号无口令，即用户不需要口令就能登录系统 例：#usermod -l user2 user1 //把用户user2改名为user1 启动、关闭防火墙永久打开或则关闭 chkconfig iptables on chkconfig iptables off 即时生效：重启后还原 service iptables start service iptables stop 或者： /etc/init.d/iptables start /etc/init.d/iptables stop 启动VSFTP服务即时启动： /etc/init.d/vsftpd start 即时停止： /etc/init.d/vsftpd stop 开机默认VSFTP服务自动启动: 方法一:(常用\方便) [root@localhost etc]# chkconfig --list|grep vsftpd ( 查看情况) vsftpd 0:off 1:off 2:off 3:off 4:off 5:off 6:off [root@localhost etc]# chkconfig vsftpd on (执行ON设置) 或者:方法二: 修改文件 /etc/rc.local , 把行/usr/local/sbin/vsftpd &amp; 插入文件中，以实现开机自动启动。 vi技巧a. 进入输入模式 新增 (append) a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。 A：从光标所在列最後面的地方开始新增资料。 插入 (insert) i：从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。 I ：从光标所在列的第一个非空白字元前面开始插入资料。 开始 (open) o ：在光标所在列下新增一列并进入输入模式。 O: 在光标所在列上方新增一列并进入输入模式。 b. 退出vi 在指令模式下键入:q,:q!,:wq或:x(注意:号），就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出，如果文件已有新的变化，vi会提示你保存文件而:q命令也会失效，这时你可以用:w命令保存文件后再用:q 退出，或用:wq或:x命令退出，如果你不想保存改变后的文件，你就需要用:q!命令，这个命令将不保存文件而直接退出vi。 c. 删除与修改文件的命令： x：删除光标所在字符。 dd ：删除光标所在的列。 r ：修改光标所在字元，r 後接著要修正的字符。 R：进入取替换状态，新增文字会覆盖原先文字，直到按 [ESC] 回到指令模式下为止。 s：删除光标所在字元，并进入输入模式。 S：删除光标所在的列，并进入输入模式。 d. 屏幕翻滚类命令 Ctrl+u: 向文件首翻半屏 Ctrl+d: 向文件尾翻半屏 Ctrl+f: 向文件尾翻一屏 Ctrl＋b: 向文件首翻一屏 nz: 将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 e. 删除命令 ndw或ndW: 删除光标处开始及其后的n-1个字 do: 删至行首 d$: 删至行尾 ndd: 删除当前行及其后n-1行 x或X: 删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u: 删除输入方式下所输入的文本 f. 搜索及替换命令 /pattern: 从光标开始处向文件尾搜索pattern ?pattern: 从光标开始处向文件首搜索pattern n: 在同一方向重复上一次搜索命令 N: 在反方向上重复上一次搜索命令 :s/p1/p2/g: 将当前行中所有p1均用p2替代 :n1,n2s/p1/p2/g: 将第n1至n2行中所有p1均用p2替代 :g/p1/s//p2/g: 将文件中所有p1均用p2替换 g. 复制，黏贴 (1) 选定文本块，使用v进入可视模式；移动光标键选定内容 (2) 复制选定块到缓冲区，用y；复制整行，用yy (3) 剪切选定块到缓冲区，用d；剪切整行用dd (4) 粘贴缓冲区中的内容，用p h. 其他 在同一编辑窗打开第二个文件，用:sp [filename] 在多个编辑文件之间切换，用Ctrl+w]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>